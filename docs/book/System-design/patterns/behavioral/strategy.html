<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>strategy - TypeScriptによるデザインパターン実装ガイド</title>


        <!-- Custom HTML head -->

        <meta name="description" content="TypeScriptで実装するGoF23デザインパターン解説ドキュメント">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../../";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">TypeScriptによるデザインパターン実装ガイド</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/2f0833e717/gof23-typescript" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/2f0833e717/gof23-typescript/edit/main/./System-design/patterns/behavioral/strategy.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="strategyパターン---アルゴリズム切替実装"><a class="header" href="#strategyパターン---アルゴリズム切替実装">Strategyパターン - アルゴリズム切替実装</a></h1>
<h2 id="1-概要"><a class="header" href="#1-概要">1. 概要</a></h2>
<h3 id="11-パターンの定義"><a class="header" href="#11-パターンの定義">1.1 パターンの定義</a></h3>
<p>Strategyパターンは、アルゴリズムのファミリーをカプセル化し、それらを交換可能にする行動パターンです。アルゴリズムをクラスとして定義し、実行時に動的に切り替えることを可能にします。これにより、クライアントコードから具体的なアルゴリズムの実装を分離します。</p>
<h3 id="12-目的解決する問題"><a class="header" href="#12-目的解決する問題">1.2 目的・解決する問題</a></h3>
<ul>
<li>アルゴリズムの動的な切り替えを可能にする</li>
<li>条件分岐の複雑化を防止する</li>
<li>アルゴリズムの独立した進化と再利用を促進する</li>
<li>オブジェクト間の結合度を低減する</li>
<li>同じ問題に対する異なる解決策を提供する</li>
<li>実行時にクライアントの振る舞いを変更できるようにする</li>
</ul>
<h3 id="13-コンテキスト適用場面"><a class="header" href="#13-コンテキスト適用場面">1.3 コンテキスト・適用場面</a></h3>
<ul>
<li>異なるバリエーションのアルゴリズムが必要な場合</li>
<li>実行時にアルゴリズムを選択する必要がある場合</li>
<li>条件分岐が複雑化しているコードのリファクタリング</li>
<li>コンポーネントに複数の振る舞いが存在し、それらを動的に変更したい場合</li>
<li>パフォーマンス最適化のために異なるアルゴリズムを使用したい場合</li>
<li>ビジネスルールや環境によって処理方法が変化する場合</li>
</ul>
<h2 id="2-クラス構造"><a class="header" href="#2-クラス構造">2. クラス構造</a></h2>
<h3 id="21-クラス図"><a class="header" href="#21-クラス図">2.1 クラス図</a></h3>
<pre class="mermaid">classDiagram
    class Context {
        -strategy: Strategy
        +setStrategy(strategy: Strategy): void
        +executeStrategy(): Result
    }
    
    class Strategy {
        +execute(data: Data): Result
    }
    
    class ConcreteStrategyA {
        +execute(data: Data): Result
    }
    
    class ConcreteStrategyB {
        +execute(data: Data): Result
    }
    
    class ConcreteStrategyC {
        +execute(data: Data): Result
    }
    
    Context --&gt; Strategy: uses &gt;
    Strategy &lt;|.. ConcreteStrategyA: implements
    Strategy &lt;|.. ConcreteStrategyB: implements
    Strategy &lt;|.. ConcreteStrategyC: implements
    
    note for Strategy &quot;インターフェース&quot;
</pre>
<h3 id="22-主要コンポーネント"><a class="header" href="#22-主要コンポーネント">2.2 主要コンポーネント</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コンポーネント</th><th>種類</th><th>責務</th><th>関連</th></tr></thead><tbody>
<tr><td>Strategy</td><td>インターフェース</td><td>アルゴリズムの共通インターフェースを定義</td><td>ConcreteStrategyで実装される</td></tr>
<tr><td>ConcreteStrategy</td><td>クラス</td><td>Strategy インターフェースの具体的実装を提供</td><td>Strategy を実装</td></tr>
<tr><td>Context</td><td>クラス</td><td>Strategy オブジェクトを保持し、必要に応じて切り替える</td><td>Strategy を使用</td></tr>
</tbody></table>
</div>
<h3 id="23-相互作用"><a class="header" href="#23-相互作用">2.3 相互作用</a></h3>
<ul>
<li>Contextはアルゴリズムの実行をStrategyオブジェクトに委譲する</li>
<li>クライアントはContextに特定のConcreteStrategyを設定する</li>
<li>Contextは具体的な実装の詳細を知らずにStrategyを使用する</li>
<li>ConcreteStrategyはアルゴリズムの特定の実装を提供する</li>
<li>異なるConcreteStrategyは同じインターフェースを共有するため交換可能である</li>
</ul>
<h2 id="3-振る舞い"><a class="header" href="#3-振る舞い">3. 振る舞い</a></h2>
<h3 id="31-シーケンス図"><a class="header" href="#31-シーケンス図">3.1 シーケンス図</a></h3>
<pre class="mermaid">sequenceDiagram
    participant Client
    participant Context
    participant ConcreteStrategyA
    participant ConcreteStrategyB
    
    Client-&gt;&gt;Context: new Context(strategyA)
    activate Context
    Context-&gt;&gt;ConcreteStrategyA: new ConcreteStrategyA()
    activate ConcreteStrategyA
    ConcreteStrategyA--&gt;&gt;Context: strategyA
    deactivate ConcreteStrategyA
    Context--&gt;&gt;Client: context
    deactivate Context
    
    Client-&gt;&gt;Context: executeStrategy(data)
    activate Context
    Context-&gt;&gt;ConcreteStrategyA: execute(data)
    activate ConcreteStrategyA
    ConcreteStrategyA--&gt;&gt;Context: result
    deactivate ConcreteStrategyA
    Context--&gt;&gt;Client: result
    deactivate Context
    
    Client-&gt;&gt;Context: setStrategy(strategyB)
    activate Context
    Context-&gt;&gt;ConcreteStrategyB: new ConcreteStrategyB()
    activate ConcreteStrategyB
    ConcreteStrategyB--&gt;&gt;Context: strategyB
    deactivate ConcreteStrategyB
    Context--&gt;&gt;Client: void
    deactivate Context
    
    Client-&gt;&gt;Context: executeStrategy(data)
    activate Context
    Context-&gt;&gt;ConcreteStrategyB: execute(data)
    activate ConcreteStrategyB
    ConcreteStrategyB--&gt;&gt;Context: result
    deactivate ConcreteStrategyB
    Context--&gt;&gt;Client: result
    deactivate Context
</pre>
<h3 id="32-プロセスフロー"><a class="header" href="#32-プロセスフロー">3.2 プロセスフロー</a></h3>
<pre class="mermaid">flowchart TD
    A[開始] --&gt; B[クライアントがContextを作成]
    B --&gt; C[クライアントが初期Strategyを設定]
    C --&gt; D[クライアントがContextのメソッドを呼び出す]
    D --&gt; E[ContextがStrategyに処理を委譲]
    E --&gt; F[Strategyがアルゴリズムを実行]
    F --&gt; G[結果がContextを経由してクライアントに返される]
    G --&gt; H{戦略を変更する?}
    H --&gt;|Yes| I[クライアントが新しいStrategyを設定]
    I --&gt; D
    H --&gt;|No| J[終了]
</pre>
<h3 id="33-重要なシナリオ"><a class="header" href="#33-重要なシナリオ">3.3 重要なシナリオ</a></h3>
<h4 id="シナリオ1-ソートアルゴリズムの切り替え"><a class="header" href="#シナリオ1-ソートアルゴリズムの切り替え">シナリオ1: ソートアルゴリズムの切り替え</a></h4>
<ol>
<li>クライアントがデータサイズに基づいて適切なソートアルゴリズムを選択</li>
<li>小さいデータセットにはクイックソートを使用</li>
<li>大きいデータセットにはマージソートを使用</li>
<li>メモリ制約のある環境ではヒープソートを使用</li>
</ol>
<h4 id="シナリオ2-支払い方法の切り替え"><a class="header" href="#シナリオ2-支払い方法の切り替え">シナリオ2: 支払い方法の切り替え</a></h4>
<ol>
<li>ECサイトで注文処理を行う</li>
<li>ユーザーが支払い方法を選択（クレジットカード、PayPal、銀行振込など）</li>
<li>選択に応じて適切な支払い処理戦略が設定される</li>
<li>注文確定時に選択された支払い方法で処理が実行される</li>
</ol>
<h2 id="4-実装詳細"><a class="header" href="#4-実装詳細">4. 実装詳細</a></h2>
<h3 id="41-主要インターフェースクラス"><a class="header" href="#41-主要インターフェースクラス">4.1 主要インターフェース・クラス</a></h3>
<pre><code class="language-typescript">/**
 * 戦略インターフェース
 * すべてのソートアルゴリズムが実装する共通インターフェース
 */
interface SortStrategy&lt;T&gt; {
    /**
     * データをソートする
     * @param data ソート対象のデータ配列
     * @returns ソート済みの配列
     */
    sort(data: T[]): T[];
    
    /**
     * 戦略の名前を取得する
     * @returns 戦略の名前
     */
    getName(): string;
}

/**
 * クイックソート戦略
 */
class QuickSort&lt;T&gt; implements SortStrategy&lt;T&gt; {
    /**
     * クイックソートアルゴリズムを使用してデータをソートする
     * @param data ソート対象のデータ配列
     * @returns ソート済みの配列
     */
    sort(data: T[]): T[] {
        // 元の配列を変更しないようにコピーを作成
        const arr = [...data];
        return this.quickSort(arr);
    }
    
    /**
     * クイックソートの再帰的実装
     * @param arr ソート対象の配列
     * @returns ソート済みの配列
     */
    private quickSort(arr: T[]): T[] {
        if (arr.length &lt;= 1) return arr;
        
        const pivot = arr[Math.floor(arr.length / 2)];
        const left = arr.filter(x =&gt; x &lt; pivot);
        const middle = arr.filter(x =&gt; x === pivot);
        const right = arr.filter(x =&gt; x &gt; pivot);
        
        return [...this.quickSort(left), ...middle, ...this.quickSort(right)];
    }
    
    /**
     * 戦略の名前を取得
     * @returns 戦略の名前
     */
    getName(): string {
        return 'クイックソート';
    }
}

/**
 * マージソート戦略
 */
class MergeSort&lt;T&gt; implements SortStrategy&lt;T&gt; {
    /**
     * マージソートアルゴリズムを使用してデータをソートする
     * @param data ソート対象のデータ配列
     * @returns ソート済みの配列
     */
    sort(data: T[]): T[] {
        // 元の配列を変更しないようにコピーを作成
        const arr = [...data];
        return this.mergeSort(arr);
    }
    
    /**
     * マージソートの再帰的実装
     * @param arr ソート対象の配列
     * @returns ソート済みの配列
     */
    private mergeSort(arr: T[]): T[] {
        if (arr.length &lt;= 1) return arr;
        
        const mid = Math.floor(arr.length / 2);
        const left = arr.slice(0, mid);
        const right = arr.slice(mid);
        
        return this.merge(
            this.mergeSort(left),
            this.mergeSort(right)
        );
    }
    
    /**
     * 2つのソート済み配列をマージする
     * @param left 左側のソート済み配列
     * @param right 右側のソート済み配列
     * @returns マージされたソート済み配列
     */
    private merge(left: T[], right: T[]): T[] {
        const result: T[] = [];
        let leftIndex = 0;
        let rightIndex = 0;
        
        while (leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) {
            if (left[leftIndex] &lt; right[rightIndex]) {
                result.push(left[leftIndex++]);
            } else {
                result.push(right[rightIndex++]);
            }
        }
        
        return result
            .concat(left.slice(leftIndex))
            .concat(right.slice(rightIndex));
    }
    
    /**
     * 戦略の名前を取得
     * @returns 戦略の名前
     */
    getName(): string {
        return 'マージソート';
    }
}

/**
 * ソートコンテキスト
 * ソート戦略を使用してデータをソートする
 */
class SortContext&lt;T&gt; {
    /**
     * 現在の戦略
     */
    private strategy: SortStrategy&lt;T&gt;;
    
    /**
     * コンストラクタ
     * @param strategy 初期ソート戦略
     */
    constructor(strategy: SortStrategy&lt;T&gt;) {
        this.strategy = strategy;
    }
    
    /**
     * 戦略を設定する
     * @param strategy 新しいソート戦略
     */
    setStrategy(strategy: SortStrategy&lt;T&gt;): void {
        this.strategy = strategy;
    }
    
    /**
     * 現在の戦略を取得する
     * @returns 現在のソート戦略
     */
    getStrategy(): SortStrategy&lt;T&gt; {
        return this.strategy;
    }
    
    /**
     * 現在の戦略を使用してデータをソートする
     * @param data ソート対象のデータ配列
     * @returns ソート済みの配列
     */
    sort(data: T[]): T[] {
        console.log(`${this.strategy.getName()}を使用してソートします`);
        return this.strategy.sort(data);
    }
}
</code></pre>
<h3 id="42-ストラテジー選択ロジック"><a class="header" href="#42-ストラテジー選択ロジック">4.2 ストラテジー選択ロジック</a></h3>
<pre><code class="language-typescript">/**
 * データサイズに基づいて最適なソート戦略を選択するファクトリ
 */
class SortStrategyFactory {
    /**
     * データサイズに基づいて最適なソート戦略を選択する
     * @param dataSize データのサイズ
     * @returns 最適なソート戦略
     */
    static getOptimalStrategy&lt;T&gt;(dataSize: number): SortStrategy&lt;T&gt; {
        if (dataSize &lt;= 10) {
            // 小さいデータセットには挿入ソートが効率的
            return new InsertionSort&lt;T&gt;();
        } else if (dataSize &lt;= 1000) {
            // 中程度のデータセットにはクイックソートが効率的
            return new QuickSort&lt;T&gt;();
        } else {
            // 大きいデータセットにはマージソートが安定
            return new MergeSort&lt;T&gt;();
        }
    }
    
    /**
     * メモリ使用量に基づいて最適なソート戦略を選択する
     * @param memoryConstrained メモリ制約があるかどうか
     * @returns 最適なソート戦略
     */
    static getMemoryEfficientStrategy&lt;T&gt;(memoryConstrained: boolean): SortStrategy&lt;T&gt; {
        if (memoryConstrained) {
            // メモリ制約がある場合はヒープソートが効率的
            return new HeapSort&lt;T&gt;();
        } else {
            // メモリが十分ある場合はマージソートが安定
            return new MergeSort&lt;T&gt;();
        }
    }
}
</code></pre>
<h3 id="43-実装のバリエーション"><a class="header" href="#43-実装のバリエーション">4.3 実装のバリエーション</a></h3>
<ol>
<li>
<p><strong>基本戦略</strong></p>
<ul>
<li>インターフェースを実装した単純な戦略クラス</li>
<li>例: ソートアルゴリズム、検証アルゴリズム</li>
</ul>
</li>
<li>
<p><strong>パラメータ化戦略</strong></p>
<ul>
<li>戦略の振る舞いをパラメータで調整できる実装</li>
<li>例: ソートの昇順・降順の切り替え</li>
</ul>
</li>
<li>
<p><strong>関数型戦略</strong></p>
<ul>
<li>戦略をクラスではなく関数として実装</li>
<li>例: 関数オブジェクトを使用</li>
</ul>
</li>
<li>
<p><strong>複合戦略</strong></p>
<ul>
<li>複数の戦略を組み合わせた実装</li>
<li>例: ソートと検索のパイプライン</li>
</ul>
</li>
</ol>
<h3 id="44-注意すべき実装ポイント"><a class="header" href="#44-注意すべき実装ポイント">4.4 注意すべき実装ポイント</a></h3>
<ul>
<li>戦略クラスのインターフェースは単純に保ち、必要最小限のメソッドを定義する</li>
<li>戦略間で共通する処理はヘルパーメソッドとして抽出する</li>
<li>コンテキストは戦略の実装詳細に依存しないようにする</li>
<li>新しい戦略の追加が容易になるように設計する</li>
<li>パフォーマンスとメモリ使用量の影響を考慮する</li>
<li>戦略の切り替えコストを検討する（頻繁に変更される場合、軽量な実装が必要）</li>
<li>戦略クラスの状態管理に注意する（ステートレスが望ましい）</li>
</ul>
<h2 id="5-使用例"><a class="header" href="#5-使用例">5. 使用例</a></h2>
<h3 id="51-基本的な使用例"><a class="header" href="#51-基本的な使用例">5.1 基本的な使用例</a></h3>
<pre><code class="language-typescript">// クイックソート戦略を使用してコンテキストを初期化
const sorter = new SortContext&lt;number&gt;(new QuickSort&lt;number&gt;());

// 小さいデータセットをソート
const smallData = [3, 1, 4, 1, 5, 9, 2, 6, 5];
console.log('元のデータ:', smallData);
console.log('ソート結果:', sorter.sort(smallData));  // クイックソートで処理

// 大きいデータセットには別の戦略に切り替え
sorter.setStrategy(new MergeSort&lt;number&gt;());

// 大きいデータセットをソート
const largeData = Array.from({length: 1000}, () =&gt; Math.floor(Math.random() * 1000));
console.log('大きいデータをソート中...');
console.log('ソート結果の最初の10項目:', sorter.sort(largeData).slice(0, 10));  // マージソートで処理

// メモリ制約がある環境向けにヒープソートに切り替え
sorter.setStrategy(new HeapSort&lt;number&gt;());

// メモリ効率重視でソート
console.log('メモリ効率重視でソート中...');
console.log('ソート結果の最初の10項目:', sorter.sort(largeData).slice(0, 10));  // ヒープソートで処理
</code></pre>
<h3 id="52-高度な使用例"><a class="header" href="#52-高度な使用例">5.2 高度な使用例</a></h3>
<pre><code class="language-typescript">/**
 * データ分析アプリケーション
 * 複数のソート戦略を使用してデータを処理する
 */
class DataAnalyzer&lt;T&gt; {
    private sortContext: SortContext&lt;T&gt;;
    private data: T[];
    
    /**
     * コンストラクタ
     * @param data 分析対象のデータ
     */
    constructor(data: T[]) {
        // デフォルトの戦略を設定
        this.sortContext = new SortContext&lt;T&gt;(new QuickSort&lt;T&gt;());
        this.data = [...data];
    }
    
    /**
     * データサイズに最適な戦略を自動選択してソート
     * @returns ソート済みデータ
     */
    sortWithOptimalStrategy(): T[] {
        const dataSize = this.data.length;
        const strategy = SortStrategyFactory.getOptimalStrategy&lt;T&gt;(dataSize);
        
        console.log(`データサイズ: ${dataSize}、選択された戦略: ${strategy.getName()}`);
        this.sortContext.setStrategy(strategy);
        return this.sortContext.sort(this.data);
    }
    
    /**
     * 特定の環境条件に基づいてソート
     * @param memoryConstrained メモリ制約があるかどうか
     * @returns ソート済みデータ
     */
    sortWithEnvironmentConstraints(memoryConstrained: boolean): T[] {
        const strategy = SortStrategyFactory.getMemoryEfficientStrategy&lt;T&gt;(memoryConstrained);
        
        console.log(`メモリ制約: ${memoryConstrained ? 'あり' : 'なし'}、選択された戦略: ${strategy.getName()}`);
        this.sortContext.setStrategy(strategy);
        return this.sortContext.sort(this.data);
    }
    
    /**
     * カスタム指標に基づいてデータを分析
     * @param metrics 分析メトリクスの配列
     * @returns 分析結果
     */
    analyzeWithMetrics(metrics: Array&lt;(data: T[]) =&gt; any&gt;): any[] {
        // データをソート
        const sortedData = this.sortWithOptimalStrategy();
        
        // 各メトリクスを計算
        return metrics.map(metric =&gt; metric(sortedData));
    }
}

// 使用例
const randomData = Array.from({length: 5000}, () =&gt; Math.floor(Math.random() * 10000));
const analyzer = new DataAnalyzer&lt;number&gt;(randomData);

// 最適な戦略でソート
const sortedData = analyzer.sortWithOptimalStrategy();
console.log('ソート済みデータの最初の10項目:', sortedData.slice(0, 10));

// メモリ制約環境でソート
const memoryEfficientSort = analyzer.sortWithEnvironmentConstraints(true);
console.log('メモリ効率的なソートの最初の10項目:', memoryEfficientSort.slice(0, 10));

// カスタムメトリクスで分析
const metrics = [
    (data: number[]) =&gt; ({ min: data[0], max: data[data.length - 1] }),
    (data: number[]) =&gt; ({ avg: data.reduce((sum, val) =&gt; sum + val, 0) / data.length }),
    (data: number[]) =&gt; ({ median: data[Math.floor(data.length / 2)] })
];

const analysisResults = analyzer.analyzeWithMetrics(metrics);
console.log('分析結果:', analysisResults);
</code></pre>
<h2 id="6-テスト戦略"><a class="header" href="#6-テスト戦略">6. テスト戦略</a></h2>
<h3 id="61-ユニットテスト要件"><a class="header" href="#61-ユニットテスト要件">6.1 ユニットテスト要件</a></h3>
<ul>
<li>各具体的な戦略が期待通りの結果を返すことをテストする</li>
<li>コンテキストが正しく戦略を切り替えることをテストする</li>
<li>戦略の切り替えが実行結果に影響することをテストする</li>
<li>エッジケース（空の配列、単一要素の配列など）のテスト</li>
<li>パフォーマンス特性のテスト（大規模データセットでの各戦略の効率性）</li>
</ul>
<h3 id="62-テスト実装例"><a class="header" href="#62-テスト実装例">6.2 テスト実装例</a></h3>
<pre><code class="language-typescript">describe('Strategy Pattern Tests', () =&gt; {
    describe('Sort Strategies', () =&gt; {
        const unsortedData = [5, 3, 1, 4, 2];
        const expectedSortedData = [1, 2, 3, 4, 5];
        
        test('QuickSort strategy should sort data correctly', () =&gt; {
            const quickSort = new QuickSort&lt;number&gt;();
            const result = quickSort.sort(unsortedData);
            
            expect(result).toEqual(expectedSortedData);
            // 元の配列が変更されていないことを確認
            expect(unsortedData).toEqual([5, 3, 1, 4, 2]);
        });
        
        test('MergeSort strategy should sort data correctly', () =&gt; {
            const mergeSort = new MergeSort&lt;number&gt;();
            const result = mergeSort.sort(unsortedData);
            
            expect(result).toEqual(expectedSortedData);
        });
        
        test('HeapSort strategy should sort data correctly', () =&gt; {
            const heapSort = new HeapSort&lt;number&gt;();
            const result = heapSort.sort(unsortedData);
            
            expect(result).toEqual(expectedSortedData);
        });
        
        test('InsertionSort strategy should sort data correctly', () =&gt; {
            const insertionSort = new InsertionSort&lt;number&gt;();
            const result = insertionSort.sort(unsortedData);
            
            expect(result).toEqual(expectedSortedData);
        });
        
        test('Edge cases: empty array', () =&gt; {
            const strategies = [
                new QuickSort&lt;number&gt;(),
                new MergeSort&lt;number&gt;(),
                new HeapSort&lt;number&gt;(),
                new InsertionSort&lt;number&gt;()
            ];
            
            strategies.forEach(strategy =&gt; {
                const result = strategy.sort([]);
                expect(result).toEqual([]);
            });
        });
        
        test('Edge cases: single element array', () =&gt; {
            const strategies = [
                new QuickSort&lt;number&gt;(),
                new MergeSort&lt;number&gt;(),
                new HeapSort&lt;number&gt;(),
                new InsertionSort&lt;number&gt;()
            ];
            
            strategies.forEach(strategy =&gt; {
                const result = strategy.sort([42]);
                expect(result).toEqual([42]);
            });
        });
    });
    
    describe('SortContext', () =&gt; {
        const unsortedData = [5, 3, 1, 4, 2];
        const expectedSortedData = [1, 2, 3, 4, 5];
        
        test('SortContext should use the provided strategy', () =&gt; {
            const mockStrategy = {
                sort: jest.fn().mockReturnValue(expectedSortedData),
                getName: jest.fn().mockReturnValue('MockStrategy')
            };
            
            const sortContext = new SortContext(mockStrategy);
            const result = sortContext.sort(unsortedData);
            
            expect(mockStrategy.sort).toHaveBeenCalledWith(unsortedData);
            expect(result).toEqual(expectedSortedData);
        });
        
        test('SortContext should allow changing strategies', () =&gt; {
            const quickSort = new QuickSort&lt;number&gt;();
            const mergeSort = new MergeSort&lt;number&gt;();
            
            const sortContext = new SortContext&lt;number&gt;(quickSort);
            expect(sortContext.getStrategy()).toBe(quickSort);
            
            sortContext.setStrategy(mergeSort);
            expect(sortContext.getStrategy()).toBe(mergeSort);
        });
        
        test('SortContext should use the current strategy for sorting', () =&gt; {
            const quickSort = {
                sort: jest.fn().mockReturnValue(expectedSortedData),
                getName: jest.fn().mockReturnValue('QuickSort')
            };
            
            const mergeSort = {
                sort: jest.fn().mockReturnValue(expectedSortedData),
                getName: jest.fn().mockReturnValue('MergeSort')
            };
            
            const sortContext = new SortContext(quickSort);
            sortContext.sort(unsortedData);
            
            expect(quickSort.sort).toHaveBeenCalledWith(unsortedData);
            expect(mergeSort.sort).not.toHaveBeenCalled();
            
            // 戦略を変更
            sortContext.setStrategy(mergeSort);
            sortContext.sort(unsortedData);
            
            expect(mergeSort.sort).toHaveBeenCalledWith(unsortedData);
            // quickSortが再度呼ばれていないことを確認
            expect(quickSort.sort).toHaveBeenCalledTimes(1);
        });
    });
    
    describe('SortStrategyFactory', () =&gt; {
        test('should select InsertionSort for small datasets', () =&gt; {
            const strategy = SortStrategyFactory.getOptimalStrategy&lt;number&gt;(5);
            expect(strategy).toBeInstanceOf(InsertionSort);
        });
        
        test('should select QuickSort for medium datasets', () =&gt; {
            const strategy = SortStrategyFactory.getOptimalStrategy&lt;number&gt;(500);
            expect(strategy).toBeInstanceOf(QuickSort);
        });
        
        test('should select MergeSort for large datasets', () =&gt; {
            const strategy = SortStrategyFactory.getOptimalStrategy&lt;number&gt;(5000);
            expect(strategy).toBeInstanceOf(MergeSort);
        });
        
        test('should select HeapSort for memory constrained environments', () =&gt; {
            const strategy = SortStrategyFactory.getMemoryEfficientStrategy&lt;number&gt;(true);
            expect(strategy).toBeInstanceOf(HeapSort);
        });
        
        test('should select MergeSort for non-memory constrained environments', () =&gt; {
            const strategy = SortStrategyFactory.getMemoryEfficientStrategy&lt;number&gt;(false);
            expect(strategy).toBeInstanceOf(MergeSort);
        });
    });
});
</code></pre>
<h2 id="7-評価"><a class="header" href="#7-評価">7. 評価</a></h2>
<h3 id="71-メリット"><a class="header" href="#71-メリット">7.1 メリット</a></h3>
<ul>
<li>アルゴリズムの動的な切り替えが可能</li>
<li>新しいアルゴリズムの追加が容易（Open/Closed原則に準拠）</li>
<li>条件分岐の複雑化を防ぎ、コードの可読性が向上</li>
<li>各アルゴリズムを独立して進化させることができる</li>
<li>アルゴリズムの再利用性が高まる</li>
<li>テストが容易になる（各アルゴリズムを個別にテスト可能）</li>
</ul>
<h3 id="72-デメリット制約"><a class="header" href="#72-デメリット制約">7.2 デメリット・制約</a></h3>
<ul>
<li>小規模なアプリケーションではオーバーエンジニアリングになる可能性</li>
<li>クライアントが具体的な戦略の存在を認識する必要がある</li>
<li>戦略クラスの増加によりクラス数が増える</li>
<li>すべての戦略が同じインターフェースに適合する必要がある</li>
<li>引数や返り値の型が統一されるため、型の不一致が発生する可能性</li>
</ul>
<h3 id="73-代替パターン関連パターン"><a class="header" href="#73-代替パターン関連パターン">7.3 代替パターン・関連パターン</a></h3>
<ul>
<li><strong>Templateメソッド</strong>: アルゴリズムの骨格を定義し、一部のステップをサブクラスで実装する</li>
<li><strong>Command</strong>: リクエストをオブジェクトとしてカプセル化するが、Strategyはアルゴリズムに特化</li>
<li><strong>State</strong>: オブジェクトの内部状態に基づいて動作を変更するが、Strategyは明示的な切り替え</li>
<li><strong>Bridge</strong>: 抽象と実装を分離するが、Strategyはアルゴリズムの交換に焦点</li>
<li><strong>Decorator</strong>: 既存のオブジェクトに機能を追加するが、Strategyは完全に置き換える</li>
</ul>
<h2 id="8-参考資料"><a class="header" href="#8-参考資料">8. 参考資料</a></h2>
<h3 id="81-内部リンク"><a class="header" href="#81-内部リンク">8.1 内部リンク</a></h3>
<ul>
<li><a href="../../src/behavioral/strategy">ソースコード</a></li>
<li><a href="../../tests/behavioral/strategy">テストコード</a></li>
</ul>
<h3 id="82-外部リンク"><a class="header" href="#82-外部リンク">8.2 外部リンク</a></h3>
<ul>
<li><a href="https://refactoring.guru/ja/design-patterns/strategy">リファクタリング・グル - Strategy パターン</a></li>
<li><a href="https://www.amazon.co.jp/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">Design Patterns: Elements of Reusable Object-Oriented Software</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../System-design/patterns/behavioral/state.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../System-design/patterns/behavioral/template-method.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../System-design/patterns/behavioral/state.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../System-design/patterns/behavioral/template-method.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../../mermaid.min.js"></script>
        <script src="../../../mermaid-init.js"></script>


    </div>
    </body>
</html>
