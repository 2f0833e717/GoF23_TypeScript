<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>state - TypeScriptによるデザインパターン実装ガイド</title>


        <!-- Custom HTML head -->

        <meta name="description" content="TypeScriptで実装するGoF23デザインパターン解説ドキュメント">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../../";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">TypeScriptによるデザインパターン実装ガイド</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/2f0833e717/gof23-typescript" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/2f0833e717/gof23-typescript/edit/main/./System-design/patterns/behavioral/state.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="stateパターン---オブジェクト状態依存振る舞い実装"><a class="header" href="#stateパターン---オブジェクト状態依存振る舞い実装">Stateパターン - オブジェクト状態依存振る舞い実装</a></h1>
<h2 id="1-概要"><a class="header" href="#1-概要">1. 概要</a></h2>
<h3 id="11-パターンの定義"><a class="header" href="#11-パターンの定義">1.1 パターンの定義</a></h3>
<p>Stateパターンは、オブジェクトの内部状態が変化したときにその振る舞いを変更できるようにするデザインパターンです。状態遷移ロジックを別々のクラスにカプセル化することで、あたかもオブジェクトがクラスを変更したかのように振る舞います。</p>
<h3 id="12-目的解決する問題"><a class="header" href="#12-目的解決する問題">1.2 目的・解決する問題</a></h3>
<ul>
<li>状態依存の振る舞いの管理と分離</li>
<li>複雑な条件分岐（if-else、switch文）の削減</li>
<li>コードの可読性と保守性の向上</li>
<li>状態遷移の明確化と制御</li>
<li>単一責任の原則の実現</li>
<li>新しい状態の追加を容易にする</li>
<li>状態固有のロジックを局所化する</li>
</ul>
<h3 id="13-コンテキスト適用場面"><a class="header" href="#13-コンテキスト適用場面">1.3 コンテキスト・適用場面</a></h3>
<ul>
<li>オブジェクトの振る舞いが現在の状態に依存する場合</li>
<li>大量の条件分岐がある場合</li>
<li>同じ条件チェックが複数のメソッドで繰り返される場合</li>
<li>ビジネスプロセスの状態管理（注文、予約、タスク管理など）</li>
<li>ワークフローシステム</li>
<li>ゲームのキャラクター状態管理</li>
<li>UIコンポーネントの状態制御</li>
</ul>
<h2 id="2-クラス構造"><a class="header" href="#2-クラス構造">2. クラス構造</a></h2>
<h3 id="21-クラス図"><a class="header" href="#21-クラス図">2.1 クラス図</a></h3>
<pre class="mermaid">classDiagram
    class Context {
        -state: State
        +setState(state: State): void
        +request1(): void
        +request2(): void
    }
    
    class State {
        +handle1(context: Context): void
        +handle2(context: Context): void
    }
    
    class ConcreteStateA {
        +handle1(context: Context): void
        +handle2(context: Context): void
    }
    
    class ConcreteStateB {
        +handle1(context: Context): void
        +handle2(context: Context): void
    }
    
    class ConcreteStateC {
        +handle1(context: Context): void
        +handle2(context: Context): void
    }
    
    Context --&gt; State : uses
    State &lt;|.. ConcreteStateA : implements
    State &lt;|.. ConcreteStateB : implements
    State &lt;|.. ConcreteStateC : implements
    
    note for State &quot;インターフェース&quot;
</pre>
<h3 id="22-主要コンポーネント"><a class="header" href="#22-主要コンポーネント">2.2 主要コンポーネント</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コンポーネント</th><th>種類</th><th>責務</th><th>関連</th></tr></thead><tbody>
<tr><td>Context</td><td>クラス</td><td>状態オブジェクトの現在のインスタンスを保持し、クライアントからの要求を現在の状態に委譲</td><td>State を参照</td></tr>
<tr><td>State</td><td>インターフェース</td><td>Context の状態依存の振る舞いを定義するメソッドを宣言</td><td>-</td></tr>
<tr><td>ConcreteState</td><td>クラス</td><td>State インターフェースを実装し、特定の状態に関連する振る舞いを提供</td><td>State を実装</td></tr>
</tbody></table>
</div>
<h3 id="23-相互作用"><a class="header" href="#23-相互作用">2.3 相互作用</a></h3>
<ul>
<li>Context は現在の State オブジェクトへの参照を保持</li>
<li>クライアントからの要求は Context によって現在の State に委譲される</li>
<li>Context は State に自身の参照を渡し、State が必要に応じて Context の状態を変更できるようにする</li>
<li>State は Context の状態を変更するために Context の setState メソッドを呼び出す</li>
<li>Context は ConcreteState インスタンスを作成せず、外部から注入されることが多い</li>
</ul>
<h2 id="3-シーケンス"><a class="header" href="#3-シーケンス">3. シーケンス</a></h2>
<h3 id="31-基本フロー"><a class="header" href="#31-基本フロー">3.1 基本フロー</a></h3>
<pre class="mermaid">sequenceDiagram
    participant Client
    participant Context
    participant StateA
    participant StateB
    
    Client-&gt;&gt;Context: request1()
    activate Context
    Context-&gt;&gt;StateA: handle1(context)
    activate StateA
    StateA-&gt;&gt;Context: setState(new StateB())
    Context--&gt;&gt;StateA: 
    deactivate StateA
    Context--&gt;&gt;Client: 
    deactivate Context
    
    Client-&gt;&gt;Context: request2()
    activate Context
    Context-&gt;&gt;StateB: handle2(context)
    activate StateB
    StateB--&gt;&gt;Context: result
    deactivate StateB
    Context--&gt;&gt;Client: result
    deactivate Context
</pre>
<h3 id="32-注文処理の例"><a class="header" href="#32-注文処理の例">3.2 注文処理の例</a></h3>
<pre class="mermaid">sequenceDiagram
    participant Client
    participant Order
    participant NewOrderState
    participant ProcessingState
    participant PaidState
    participant ShippedState
    
    Client-&gt;&gt;Order: process()
    activate Order
    Order-&gt;&gt;NewOrderState: processOrder(order)
    activate NewOrderState
    NewOrderState-&gt;&gt;Order: setState(new ProcessingState())
    Order--&gt;&gt;NewOrderState: 
    deactivate NewOrderState
    Order--&gt;&gt;Client: 
    deactivate Order
    
    Client-&gt;&gt;Order: pay()
    activate Order
    Order-&gt;&gt;ProcessingState: payOrder(order)
    activate ProcessingState
    ProcessingState-&gt;&gt;Order: setState(new PaidState())
    Order--&gt;&gt;ProcessingState: 
    deactivate ProcessingState
    Order--&gt;&gt;Client: 
    deactivate Order
    
    Client-&gt;&gt;Order: ship()
    activate Order
    Order-&gt;&gt;PaidState: shipOrder(order)
    activate PaidState
    PaidState-&gt;&gt;Order: setState(new ShippedState())
    Order--&gt;&gt;PaidState: 
    deactivate PaidState
    Order--&gt;&gt;Client: 
    deactivate Order
</pre>
<h3 id="33-プロセスフロー"><a class="header" href="#33-プロセスフロー">3.3 プロセスフロー</a></h3>
<pre class="mermaid">flowchart TD
    A[開始] --&gt; B[Context オブジェクトの作成]
    B --&gt; C[初期状態の設定]
    C --&gt; D[クライアントがContext.requestを呼び出す]
    D --&gt; E[Context が現在の状態.handleを呼び出す]
    E --&gt; F[現在の状態が処理を実行]
    F --&gt; G{状態遷移が必要か?}
    G --&gt;|はい| H[状態オブジェクトがContext.setStateを呼び出す]
    H --&gt; D
    G --&gt;|いいえ| I[処理完了]
    I --&gt; J[終了]
</pre>
<h3 id="34-重要なシナリオ"><a class="header" href="#34-重要なシナリオ">3.4 重要なシナリオ</a></h3>
<h4 id="シナリオ1-注文処理ワークフロー"><a class="header" href="#シナリオ1-注文処理ワークフロー">シナリオ1: 注文処理ワークフロー</a></h4>
<ol>
<li>新規注文が作成され、初期状態は「新規注文」</li>
<li>注文処理が開始され、状態が「処理中」に変わる</li>
<li>支払いが完了すると、状態が「支払済み」に変わる</li>
<li>商品が発送されると、状態が「発送済み」に変わる</li>
<li>各状態で許可される操作と禁止される操作が異なる</li>
</ol>
<h4 id="シナリオ2-有限状態マシンfsmの実装"><a class="header" href="#シナリオ2-有限状態マシンfsmの実装">シナリオ2: 有限状態マシン（FSM）の実装</a></h4>
<ol>
<li>システムは特定の入力イベントに応じて状態間を遷移する</li>
<li>各状態は特定の入力に対して異なる反応を示す</li>
<li>次の状態は現在の状態と入力イベントの組み合わせによって決まる</li>
<li>特定の状態では特定の出力アクションが実行される</li>
</ol>
<h2 id="4-実装詳細"><a class="header" href="#4-実装詳細">4. 実装詳細</a></h2>
<h3 id="41-主要インターフェースクラス"><a class="header" href="#41-主要インターフェースクラス">4.1 主要インターフェース・クラス</a></h3>
<pre><code class="language-typescript">/**
 * 注文状態インターフェース
 * 各状態が実装すべきメソッドを定義
 */
interface OrderState {
    /**
     * 注文を処理する
     * @param order 処理する注文
     */
    processOrder(order: Order): void;
    
    /**
     * 注文をキャンセルする
     * @param order キャンセルする注文
     */
    cancelOrder(order: Order): void;
    
    /**
     * 注文の支払いを行う
     * @param order 支払いを行う注文
     */
    payOrder(order: Order): void;
    
    /**
     * 注文を発送する
     * @param order 発送する注文
     */
    shipOrder(order: Order): void;
    
    /**
     * 状態の名前を取得する
     * @returns 状態の名前
     */
    getName(): string;
}

/**
 * 注文クラス（Context）
 * 現在の状態を管理し、操作を適切な状態に委譲する
 */
class Order {
    /**
     * 現在の注文状態
     */
    private state: OrderState;
    
    /**
     * 注文ID
     */
    private readonly id: string;
    
    /**
     * 注文アイテムのリスト
     */
    private items: string[];
    
    /**
     * 注文の履歴
     */
    private history: string[] = [];
    
    /**
     * コンストラクタ
     * @param id 注文ID
     */
    constructor(id: string) {
        this.id = id;
        this.items = [];
        this.state = new NewOrderState();
        this.logStateChange('初期化', this.state.getName());
    }
    
    /**
     * 注文状態を設定する
     * @param state 設定する状態
     */
    setState(state: OrderState): void {
        const oldState = this.state.getName();
        this.state = state;
        this.logStateChange(oldState, state.getName());
    }
    
    /**
     * 注文を処理する
     */
    process(): void {
        this.state.processOrder(this);
    }
    
    /**
     * 注文をキャンセルする
     */
    cancel(): void {
        this.state.cancelOrder(this);
    }
    
    /**
     * 注文の支払いを行う
     */
    pay(): void {
        this.state.payOrder(this);
    }
    
    /**
     * 注文を発送する
     */
    ship(): void {
        this.state.shipOrder(this);
    }
    
    /**
     * 注文に商品を追加する
     * @param item 追加する商品
     */
    addItem(item: string): void {
        this.items.push(item);
        console.log(`Item '${item}' added to order ${this.id}`);
    }
    
    /**
     * 注文の商品リストを取得する
     * @returns 商品リストのコピー
     */
    getItems(): string[] {
        return [...this.items];
    }
    
    /**
     * 注文IDを取得する
     * @returns 注文ID
     */
    getId(): string {
        return this.id;
    }
    
    /**
     * 状態変更を記録する
     * @param fromState 元の状態
     * @param toState 変更後の状態
     */
    private logStateChange(fromState: string, toState: string): void {
        const message = `状態変更: ${fromState} → ${toState}`;
        console.log(`Order ${this.id}: ${message}`);
        this.history.push(`${new Date().toISOString()} - ${message}`);
    }
    
    /**
     * 注文履歴を取得する
     * @returns 注文履歴のコピー
     */
    getHistory(): string[] {
        return [...this.history];
    }
}
</code></pre>
<h3 id="42-状態クラスの実装"><a class="header" href="#42-状態クラスの実装">4.2 状態クラスの実装</a></h3>
<pre><code class="language-typescript">/**
 * 新規注文状態
 * 初期状態として使用される
 */
class NewOrderState implements OrderState {
    /**
     * 注文を処理する
     * @param order 処理する注文
     */
    processOrder(order: Order): void {
        console.log(`Processing order ${order.getId()}`);
        order.setState(new ProcessingState());
    }
    
    /**
     * 注文をキャンセルする
     * @param order キャンセルする注文
     */
    cancelOrder(order: Order): void {
        console.log(`Cancelling new order ${order.getId()}`);
        order.setState(new CancelledState());
    }
    
    /**
     * 注文の支払いを行う
     * @param order 支払いを行う注文
     */
    payOrder(order: Order): void {
        throw new Error('Cannot pay for order that has not been processed');
    }
    
    /**
     * 注文を発送する
     * @param order 発送する注文
     */
    shipOrder(order: Order): void {
        throw new Error('Cannot ship order that has not been processed');
    }
    
    /**
     * 状態の名前を取得する
     * @returns 状態の名前
     */
    getName(): string {
        return '新規注文';
    }
}

/**
 * 処理中状態
 * 注文が処理中であることを表す
 */
class ProcessingState implements OrderState {
    /**
     * 注文を処理する
     * @param order 処理する注文
     */
    processOrder(order: Order): void {
        throw new Error('Order is already being processed');
    }
    
    /**
     * 注文をキャンセルする
     * @param order キャンセルする注文
     */
    cancelOrder(order: Order): void {
        console.log(`Cancelling processing order ${order.getId()}`);
        order.setState(new CancelledState());
    }
    
    /**
     * 注文の支払いを行う
     * @param order 支払いを行う注文
     */
    payOrder(order: Order): void {
        console.log(`Processing payment for order ${order.getId()}`);
        order.setState(new PaidState());
    }
    
    /**
     * 注文を発送する
     * @param order 発送する注文
     */
    shipOrder(order: Order): void {
        throw new Error('Cannot ship order that has not been paid');
    }
    
    /**
     * 状態の名前を取得する
     * @returns 状態の名前
     */
    getName(): string {
        return '処理中';
    }
}

/**
 * 支払い済み状態
 * 注文が支払い済みであることを表す
 */
class PaidState implements OrderState {
    /**
     * 注文を処理する
     * @param order 処理する注文
     */
    processOrder(order: Order): void {
        throw new Error('Order is already processed and paid');
    }
    
    /**
     * 注文をキャンセルする
     * @param order キャンセルする注文
     */
    cancelOrder(order: Order): void {
        console.log(`Refunding order ${order.getId()}`);
        order.setState(new RefundedState());
    }
    
    /**
     * 注文の支払いを行う
     * @param order 支払いを行う注文
     */
    payOrder(order: Order): void {
        throw new Error('Order is already paid');
    }
    
    /**
     * 注文を発送する
     * @param order 発送する注文
     */
    shipOrder(order: Order): void {
        console.log(`Shipping order ${order.getId()}`);
        order.setState(new ShippedState());
    }
    
    /**
     * 状態の名前を取得する
     * @returns 状態の名前
     */
    getName(): string {
        return '支払い済み';
    }
}

/**
 * 発送済み状態
 * 注文が発送済みであることを表す
 */
class ShippedState implements OrderState {
    /**
     * 注文を処理する
     * @param order 処理する注文
     */
    processOrder(order: Order): void {
        throw new Error('Cannot process shipped order');
    }
    
    /**
     * 注文をキャンセルする
     * @param order キャンセルする注文
     */
    cancelOrder(order: Order): void {
        throw new Error('Cannot cancel shipped order');
    }
    
    /**
     * 注文の支払いを行う
     * @param order 支払いを行う注文
     */
    payOrder(order: Order): void {
        throw new Error('Order is already paid');
    }
    
    /**
     * 注文を発送する
     * @param order 発送する注文
     */
    shipOrder(order: Order): void {
        throw new Error('Order is already shipped');
    }
    
    /**
     * 状態の名前を取得する
     * @returns 状態の名前
     */
    getName(): string {
        return '発送済み';
    }
}

/**
 * キャンセル状態
 * 注文がキャンセルされたことを表す
 */
class CancelledState implements OrderState {
    /**
     * 注文を処理する
     * @param order 処理する注文
     */
    processOrder(order: Order): void {
        throw new Error('Cannot process cancelled order');
    }
    
    /**
     * 注文をキャンセルする
     * @param order キャンセルする注文
     */
    cancelOrder(order: Order): void {
        throw new Error('Order is already cancelled');
    }
    
    /**
     * 注文の支払いを行う
     * @param order 支払いを行う注文
     */
    payOrder(order: Order): void {
        throw new Error('Cannot pay for cancelled order');
    }
    
    /**
     * 注文を発送する
     * @param order 発送する注文
     */
    shipOrder(order: Order): void {
        throw new Error('Cannot ship cancelled order');
    }
    
    /**
     * 状態の名前を取得する
     * @returns 状態の名前
     */
    getName(): string {
        return 'キャンセル済み';
    }
}

/**
 * 返金済み状態
 * 支払い済みの注文がキャンセルされ、返金されたことを表す
 */
class RefundedState implements OrderState {
    /**
     * 注文を処理する
     * @param order 処理する注文
     */
    processOrder(order: Order): void {
        throw new Error('Cannot process refunded order');
    }
    
    /**
     * 注文をキャンセルする
     * @param order キャンセルする注文
     */
    cancelOrder(order: Order): void {
        throw new Error('Order is already cancelled and refunded');
    }
    
    /**
     * 注文の支払いを行う
     * @param order 支払いを行う注文
     */
    payOrder(order: Order): void {
        throw new Error('Cannot pay for refunded order');
    }
    
    /**
     * 注文を発送する
     * @param order 発送する注文
     */
    shipOrder(order: Order): void {
        throw new Error('Cannot ship refunded order');
    }
    
    /**
     * 状態の名前を取得する
     * @returns 状態の名前
     */
    getName(): string {
        return '返金済み';
    }
}
</code></pre>
<h3 id="43-実装のバリエーション"><a class="header" href="#43-実装のバリエーション">4.3 実装のバリエーション</a></h3>
<ol>
<li>
<p><strong>状態マシン定義型</strong></p>
<ul>
<li>状態遷移テーブルを使用して状態遷移を定義</li>
<li>各状態と動作のマッピングを中央で管理</li>
</ul>
</li>
<li>
<p><strong>階層型状態パターン</strong></p>
<ul>
<li>状態の継承階層を使用して共通動作を共有</li>
<li>特殊なケースのみ子クラスでオーバーライド</li>
</ul>
</li>
<li>
<p><strong>フライウェイト状態パターン</strong></p>
<ul>
<li>状態オブジェクトを共有して生成コストを削減</li>
<li>複数のコンテキストで同じ状態インスタンスを再利用</li>
</ul>
</li>
<li>
<p><strong>イベント駆動型状態パターン</strong></p>
<ul>
<li>イベントに基づいて状態遷移を行う</li>
<li>イベントとハンドラのマッピングを各状態で定義</li>
</ul>
</li>
</ol>
<h3 id="44-注意すべき実装ポイント"><a class="header" href="#44-注意すべき実装ポイント">4.4 注意すべき実装ポイント</a></h3>
<ul>
<li>状態クラスは無状態（ステートレス）であることが望ましく、複数のコンテキストで共有できるようにする</li>
<li>コンテキストが持つべきデータと状態クラスが持つべきデータを明確に分ける</li>
<li>無効な操作や状態遷移に対して適切な例外処理を行う</li>
<li>状態遷移の履歴を記録するメカニズムを考慮する</li>
<li>状態遷移に条件を設ける場合は、その条件を状態クラス内に明確に定義する</li>
<li>状態間の依存関係を最小限に抑える</li>
<li>状態遷移のテストを容易にするため、状態の作成と注入を明示的に行う</li>
</ul>
<h2 id="5-使用例"><a class="header" href="#5-使用例">5. 使用例</a></h2>
<h3 id="51-基本的な使用例"><a class="header" href="#51-基本的な使用例">5.1 基本的な使用例</a></h3>
<pre><code class="language-typescript">// 注文の作成と処理
const order = new Order('ORD-001');
order.addItem('製品A');
order.addItem('製品B');

console.log('--- 通常の注文処理フロー ---');
try {
    // 注文のライフサイクル
    order.process(); // NewOrderState -&gt; ProcessingState
    order.pay();     // ProcessingState -&gt; PaidState
    order.ship();    // PaidState -&gt; ShippedState
    
    console.log('最終状態:', order.getState().getName());
    console.log('注文履歴:', order.getHistory());
} catch (error) {
    console.error('注文処理でエラーが発生しました:', error.message);
}

// 出力例:
// Item '製品A' added to order ORD-001
// Item '製品B' added to order ORD-001
// --- 通常の注文処理フロー ---
// Processing order ORD-001
// Order ORD-001: 状態変更: 新規注文 → 処理中
// Processing payment for order ORD-001
// Order ORD-001: 状態変更: 処理中 → 支払い済み
// Shipping order ORD-001
// Order ORD-001: 状態変更: 支払い済み → 発送済み
// 最終状態: 発送済み
// 注文履歴: [
//   "2023-09-01T10:15:23.456Z - 状態変更: 初期化 → 新規注文",
//   "2023-09-01T10:15:24.123Z - 状態変更: 新規注文 → 処理中",
//   "2023-09-01T10:15:25.789Z - 状態変更: 処理中 → 支払い済み",
//   "2023-09-01T10:15:26.456Z - 状態変更: 支払い済み → 発送済み"
// ]
</code></pre>
<h3 id="52-エラー処理と例外ケース"><a class="header" href="#52-エラー処理と例外ケース">5.2 エラー処理と例外ケース</a></h3>
<pre><code class="language-typescript">console.log('--- エラー処理のデモ ---');

// 注文1: 処理前に支払いしようとする
const order1 = new Order('ORD-ERR-1');
try {
    order1.pay();
} catch (error) {
    console.error(`注文 ${order1.getId()} エラー:`, error.message);
}

// 注文2: キャンセル後に発送しようとする
const order2 = new Order('ORD-ERR-2');
try {
    order2.process();
    order2.cancel();
    order2.ship();
} catch (error) {
    console.error(`注文 ${order2.getId()} エラー:`, error.message);
}

// 注文3: 発送後にキャンセルしようとする
const order3 = new Order('ORD-ERR-3');
try {
    order3.process();
    order3.pay();
    order3.ship();
    order3.cancel();
} catch (error) {
    console.error(`注文 ${order3.getId()} エラー:`, error.message);
}

// 出力例:
// --- エラー処理のデモ ---
// 注文 ORD-ERR-1 エラー: Cannot pay for order that has not been processed
// Processing order ORD-ERR-2
// Order ORD-ERR-2: 状態変更: 新規注文 → 処理中
// Cancelling processing order ORD-ERR-2
// Order ORD-ERR-2: 状態変更: 処理中 → キャンセル済み
// 注文 ORD-ERR-2 エラー: Cannot ship cancelled order
// Processing order ORD-ERR-3
// Order ORD-ERR-3: 状態変更: 新規注文 → 処理中
// Processing payment for order ORD-ERR-3
// Order ORD-ERR-3: 状態変更: 処理中 → 支払い済み
// Shipping order ORD-ERR-3
// Order ORD-ERR-3: 状態変更: 支払い済み → 発送済み
// 注文 ORD-ERR-3 エラー: Cannot cancel shipped order
</code></pre>
<h3 id="53-状態遷移の視覚化"><a class="header" href="#53-状態遷移の視覚化">5.3 状態遷移の視覚化</a></h3>
<pre><code class="language-typescript">/**
 * 状態遷移を視覚化するクラス
 */
class OrderStateDiagram {
    /**
     * 状態遷移図を生成する
     * @param order 注文オブジェクト
     * @returns 状態遷移の視覚的表現
     */
    static generateDiagram(order: Order): string {
        const history = order.getHistory();
        const states = history.map(entry =&gt; {
            const match = entry.match(/状態変更: (.+) → (.+)$/);
            return match ? match[2] : null;
        }).filter(Boolean);
        
        let diagram = '状態遷移図:\n';
        diagram += '-------------\n';
        
        states.forEach((state, index) =&gt; {
            diagram += `[${state}]`;
            if (index &lt; states.length - 1) {
                diagram += ' → ';
                if ((index + 1) % 3 === 0) {
                    diagram += '\n';
                }
            }
        });
        
        return diagram;
    }
}

// 使用例
const order4 = new Order('ORD-DIAG');
order4.process();
order4.pay();
order4.ship();

console.log(OrderStateDiagram.generateDiagram(order4));

// 出力例:
// 状態遷移図:
// -------------
// [新規注文] → [処理中] → [支払い済み] → [発送済み]
</code></pre>
<h2 id="6-テスト戦略"><a class="header" href="#6-テスト戦略">6. テスト戦略</a></h2>
<h3 id="61-ユニットテスト要件"><a class="header" href="#61-ユニットテスト要件">6.1 ユニットテスト要件</a></h3>
<ul>
<li>各状態クラスのメソッドが正しく動作することを確認</li>
<li>状態遷移が正しく行われることを確認</li>
<li>無効な操作に対して適切な例外がスローされることを確認</li>
<li>状態履歴が正しく記録されることを確認</li>
<li>境界条件や特殊ケースのテスト</li>
</ul>
<h3 id="62-テスト実装例"><a class="header" href="#62-テスト実装例">6.2 テスト実装例</a></h3>
<pre><code class="language-typescript">describe('Order State Pattern Tests', () =&gt; {
    describe('Order State Transitions', () =&gt; {
        let order: Order;
        
        beforeEach(() =&gt; {
            order = new Order('TEST-001');
        });
        
        test('初期状態は新規注文である', () =&gt; {
            expect(order['state'].getName()).toBe('新規注文');
        });
        
        test('正常な状態遷移シーケンスが機能する', () =&gt; {
            // 新規注文 → 処理中
            order.process();
            expect(order['state'].getName()).toBe('処理中');
            
            // 処理中 → 支払い済み
            order.pay();
            expect(order['state'].getName()).toBe('支払い済み');
            
            // 支払い済み → 発送済み
            order.ship();
            expect(order['state'].getName()).toBe('発送済み');
        });
        
        test('処理中の注文はキャンセルできる', () =&gt; {
            order.process();
            order.cancel();
            expect(order['state'].getName()).toBe('キャンセル済み');
        });
        
        test('支払い済みの注文をキャンセルすると返金状態になる', () =&gt; {
            order.process();
            order.pay();
            order.cancel();
            expect(order['state'].getName()).toBe('返金済み');
        });
        
        test('新規注文は支払いできない', () =&gt; {
            expect(() =&gt; order.pay()).toThrow('Cannot pay for order that has not been processed');
        });
        
        test('新規注文は発送できない', () =&gt; {
            expect(() =&gt; order.ship()).toThrow('Cannot ship order that has not been processed');
        });
        
        test('処理中の注文は発送できない', () =&gt; {
            order.process();
            expect(() =&gt; order.ship()).toThrow('Cannot ship order that has not been paid');
        });
        
        test('発送済みの注文はキャンセルできない', () =&gt; {
            order.process();
            order.pay();
            order.ship();
            expect(() =&gt; order.cancel()).toThrow('Cannot cancel shipped order');
        });
        
        test('キャンセル済みの注文は処理できない', () =&gt; {
            order.cancel();
            expect(() =&gt; order.process()).toThrow('Cannot process cancelled order');
        });
    });
    
    describe('Order History and Metadata', () =&gt; {
        test('注文の履歴が正しく記録される', () =&gt; {
            const order = new Order('HIST-001');
            order.process();
            order.pay();
            
            const history = order.getHistory();
            expect(history.length).toBe(3); // 初期化、処理、支払い
            expect(history[0]).toContain('初期化 → 新規注文');
            expect(history[1]).toContain('新規注文 → 処理中');
            expect(history[2]).toContain('処理中 → 支払い済み');
        });
        
        test('注文アイテムが正しく管理される', () =&gt; {
            const order = new Order('ITEMS-001');
            order.addItem('アイテム1');
            order.addItem('アイテム2');
            
            const items = order.getItems();
            expect(items).toEqual(['アイテム1', 'アイテム2']);
            expect(items).not.toBe(order.getItems()); // 配列のコピーが返される
        });
    });
    
    describe('State Classes', () =&gt; {
        test('各状態クラスがOrderStateインターフェースを実装している', () =&gt; {
            const states = [
                new NewOrderState(),
                new ProcessingState(),
                new PaidState(),
                new ShippedState(),
                new CancelledState(),
                new RefundedState()
            ];
            
            states.forEach(state =&gt; {
                expect(typeof state.processOrder).toBe('function');
                expect(typeof state.cancelOrder).toBe('function');
                expect(typeof state.payOrder).toBe('function');
                expect(typeof state.shipOrder).toBe('function');
                expect(typeof state.getName).toBe('function');
            });
        });
    });
});
</code></pre>
<h2 id="7-評価"><a class="header" href="#7-評価">7. 評価</a></h2>
<h3 id="71-メリット"><a class="header" href="#71-メリット">7.1 メリット</a></h3>
<ul>
<li>複雑な条件分岐を削減し、コードの可読性を向上させる</li>
<li>状態固有のロジックが局所化され、責務が明確になる</li>
<li>新しい状態の追加が既存のコードに影響を与えにくい（Open-Closed原則）</li>
<li>状態遷移ロジックが明示的で追跡しやすい</li>
<li>コンテキストクラスがシンプルになり、状態関連のバグが減少する</li>
<li>状態遷移の可視化や監査が容易になる</li>
<li>テストがしやすくなる（各状態を個別にテスト可能）</li>
</ul>
<h3 id="72-デメリット制約"><a class="header" href="#72-デメリット制約">7.2 デメリット・制約</a></h3>
<ul>
<li>クラス数が増加し、コードベースが大きくなる</li>
<li>状態が少ない単純なケースではオーバーエンジニアリングになる可能性がある</li>
<li>状態間で共有される機能の重複が発生する可能性がある</li>
<li>状態間の遷移ロジックが複雑になると管理が難しくなる</li>
<li>状態オブジェクトの生成と破棄にオーバーヘッドがかかる</li>
<li>すべての状態クラスがコンテキストの実装詳細を知る必要がある場合がある</li>
</ul>
<h3 id="73-代替パターン関連パターン"><a class="header" href="#73-代替パターン関連パターン">7.3 代替パターン・関連パターン</a></h3>
<ul>
<li><strong>State Machine（状態機械）</strong>: 状態遷移テーブルを使用して、より形式的に状態を管理</li>
<li><strong>Strategy（ストラテジー）パターン</strong>: 似た構造だが、状態の自動遷移よりも異なるアルゴリズムの切り替えに焦点</li>
<li><strong>Command（コマンド）パターン</strong>: 操作をオブジェクトにカプセル化するため、状態遷移を表現するのに使用できる</li>
<li><strong>Memento（メメント）パターン</strong>: 状態の保存と復元が必要な場合に組み合わせて使用</li>
<li><strong>Singleton（シングルトン）パターン</strong>: 状態オブジェクトが無状態の場合、シングルトンとして実装できる</li>
</ul>
<h2 id="8-参考資料"><a class="header" href="#8-参考資料">8. 参考資料</a></h2>
<h3 id="81-内部リンク"><a class="header" href="#81-内部リンク">8.1 内部リンク</a></h3>
<ul>
<li><a href="../../src/behavioral/state">ソースコード</a></li>
<li><a href="../../tests/behavioral/state">テストコード</a></li>
</ul>
<h3 id="82-外部リンク"><a class="header" href="#82-外部リンク">8.2 外部リンク</a></h3>
<ul>
<li><a href="https://refactoring.guru/ja/design-patterns/state">リファクタリング・グル - State パターン</a></li>
<li><a href="https://www.amazon.co.jp/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">Design Patterns: Elements of Reusable Object-Oriented Software</a></li>
<li><a href="https://en.wikipedia.org/wiki/Finite-state_machine">ステートパターンと有限状態機械の実装</a></li>
<li><a href="https://www.patterns.dev/posts/state-pattern">TypeScriptでのデザインパターン実装</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../System-design/patterns/behavioral/observer.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../System-design/patterns/behavioral/strategy.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../System-design/patterns/behavioral/observer.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../System-design/patterns/behavioral/strategy.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../../mermaid.min.js"></script>
        <script src="../../../mermaid-init.js"></script>


    </div>
    </body>
</html>
