<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>mediator - TypeScriptによるデザインパターン実装ガイド</title>


        <!-- Custom HTML head -->

        <meta name="description" content="TypeScriptで実装するGoF23デザインパターン解説ドキュメント">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../../";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">TypeScriptによるデザインパターン実装ガイド</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/2f0833e717/gof23-typescript" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/2f0833e717/gof23-typescript/edit/main/./System-design/patterns/behavioral/mediator.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mediatorパターン---オブジェクト間通信集約実装"><a class="header" href="#mediatorパターン---オブジェクト間通信集約実装">Mediatorパターン - オブジェクト間通信集約実装</a></h1>
<h2 id="1-概要"><a class="header" href="#1-概要">1. 概要</a></h2>
<h3 id="11-パターンの定義"><a class="header" href="#11-パターンの定義">1.1 パターンの定義</a></h3>
<p>Mediatorパターンは、オブジェクト間の通信をカプセル化するデザインパターンで、オブジェクト間の直接的な参照を減らし、それらの相互作用を中央のメディエーターオブジェクトを通じて行うようにします。これにより、システムのコンポーネント間の結合度を低減し、コンポーネントの再利用性を高めます。</p>
<h3 id="12-目的解決する問題"><a class="header" href="#12-目的解決する問題">1.2 目的・解決する問題</a></h3>
<ul>
<li>オブジェクト間の密結合を解消する</li>
<li>多対多の通信を一対多の通信に変換する</li>
<li>コンポーネント間の相互作用を一元管理する</li>
<li>システムコンポーネントの再利用性を向上させる</li>
<li>通信の複雑性を削減する</li>
<li>コードの保守性と拡張性を向上させる</li>
<li>相互依存関係のスパゲッティコードを防止する</li>
</ul>
<h3 id="13-コンテキスト適用場面"><a class="header" href="#13-コンテキスト適用場面">1.3 コンテキスト・適用場面</a></h3>
<ul>
<li>多数のオブジェクトが複雑に相互作用する場合</li>
<li>オブジェクト間の依存関係が密になりすぎている場合</li>
<li>コンポーネントを独立して再利用したい場合</li>
<li>ユーザーインターフェースコンポーネント間の調整が必要な場合</li>
<li>分散システムでのメッセージ交換</li>
<li>複雑なイベント処理システム</li>
<li>MVC/MVVMアーキテクチャのコントローラー/ビューモデルの実装</li>
</ul>
<h2 id="2-クラス構造"><a class="header" href="#2-クラス構造">2. クラス構造</a></h2>
<h3 id="21-クラス図"><a class="header" href="#21-クラス図">2.1 クラス図</a></h3>
<pre class="mermaid">classDiagram
    class Mediator {
        +notify(sender: Component, event: string): void
    }
    
    class ConcreteMediator {
        -componentA: ComponentA
        -componentB: ComponentB
        -componentC: ComponentC
        +setComponentA(component: ComponentA): void
        +setComponentB(component: ComponentB): void
        +setComponentC(component: ComponentC): void
        +notify(sender: Component, event: string): void
    }
    
    class Component {
        #mediator: Mediator
        +setMediator(mediator: Mediator): void
    }
    
    class ComponentA {
        -state: any
        +operationA(): void
        +getState(): any
    }
    
    class ComponentB {
        -state: any
        +operationB(): void
        +getState(): any
    }
    
    class ComponentC {
        -state: any
        +operationC(): void
        +getState(): any
    }
    
    Mediator &lt;|.. ConcreteMediator : implements
    Component &lt;|-- ComponentA : extends
    Component &lt;|-- ComponentB : extends
    Component &lt;|-- ComponentC : extends
    ConcreteMediator --&gt; ComponentA
    ConcreteMediator --&gt; ComponentB
    ConcreteMediator --&gt; ComponentC
    ComponentA --&gt; Mediator
    ComponentB --&gt; Mediator
    ComponentC --&gt; Mediator
    
    note for Mediator &quot;インターフェース&quot;
    note for Component &quot;抽象クラス&quot;
</pre>
<h3 id="22-主要コンポーネント"><a class="header" href="#22-主要コンポーネント">2.2 主要コンポーネント</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コンポーネント</th><th>種類</th><th>責務</th><th>関連</th></tr></thead><tbody>
<tr><td>Mediator</td><td>インターフェース</td><td>コンポーネント間の通信を仲介するためのインターフェースを定義</td><td>ConcreteMediator が実装</td></tr>
<tr><td>ConcreteMediator</td><td>クラス</td><td>コンポーネント間の具体的な連携ロジックを実装</td><td>Component を参照、Mediator を実装</td></tr>
<tr><td>Component</td><td>抽象クラス</td><td>メディエータと連携する共通メソッドを定義</td><td>ConcreteComponent の親クラス、Mediator を参照</td></tr>
<tr><td>ConcreteComponent</td><td>クラス</td><td>特定の機能を持ち、状態変更時にメディエータに通知</td><td>Component を継承</td></tr>
</tbody></table>
</div>
<h3 id="23-相互作用"><a class="header" href="#23-相互作用">2.3 相互作用</a></h3>
<ul>
<li>コンポーネントは状態変更や重要なイベントが発生した際にメディエータに通知する</li>
<li>メディエータはイベントの送信元と種類に基づいて、適切なコンポーネントに処理を委譲する</li>
<li>コンポーネントは他のコンポーネントを直接参照せず、すべての相互作用はメディエータを介して行う</li>
<li>メディエータはシステム全体の協調動作を管理し、コンポーネント間の通信ルールを定義する</li>
<li>各コンポーネントはメディエータへの参照を持ち、自身の状態変更を通知する</li>
</ul>
<h2 id="3-シーケンス"><a class="header" href="#3-シーケンス">3. シーケンス</a></h2>
<h3 id="31-基本フロー"><a class="header" href="#31-基本フロー">3.1 基本フロー</a></h3>
<pre class="mermaid">sequenceDiagram
    participant ComponentA
    participant Mediator
    participant ComponentB
    
    ComponentA-&gt;&gt;ComponentA: 内部状態変更
    ComponentA-&gt;&gt;Mediator: notify(this, &quot;eventA&quot;)
    activate Mediator
    Mediator-&gt;&gt;Mediator: イベント処理ロジック
    Mediator-&gt;&gt;ComponentB: operationB()
    activate ComponentB
    ComponentB-&gt;&gt;ComponentB: 状態更新
    ComponentB--&gt;&gt;Mediator: 処理完了
    deactivate ComponentB
    Mediator--&gt;&gt;ComponentA: 処理完了
    deactivate Mediator
</pre>
<h3 id="32-チャットルームの例"><a class="header" href="#32-チャットルームの例">3.2 チャットルームの例</a></h3>
<pre class="mermaid">sequenceDiagram
    participant User1
    participant ChatRoom
    participant User2
    participant User3
    
    Note over User1,User3: メッセージの送信
    User1-&gt;&gt;User1: メッセージ作成
    User1-&gt;&gt;ChatRoom: sendMessage(&quot;Hello&quot;, User1)
    activate ChatRoom
    ChatRoom-&gt;&gt;ChatRoom: 送信者以外のユーザーを特定
    ChatRoom-&gt;&gt;User2: receive(&quot;Hello&quot;)
    activate User2
    User2-&gt;&gt;User2: メッセージ表示
    User2--&gt;&gt;ChatRoom: 受信完了
    deactivate User2
    ChatRoom-&gt;&gt;User3: receive(&quot;Hello&quot;)
    activate User3
    User3-&gt;&gt;User3: メッセージ表示
    User3--&gt;&gt;ChatRoom: 受信完了
    deactivate User3
    ChatRoom--&gt;&gt;User1: 送信完了
    deactivate ChatRoom
    
    Note over User1,User3: 応答
    User2-&gt;&gt;ChatRoom: sendMessage(&quot;Hi!&quot;, User2)
    activate ChatRoom
    ChatRoom-&gt;&gt;User1: receive(&quot;Hi!&quot;)
    ChatRoom-&gt;&gt;User3: receive(&quot;Hi!&quot;)
    ChatRoom--&gt;&gt;User2: 送信完了
    deactivate ChatRoom
</pre>
<h3 id="33-プロセスフロー"><a class="header" href="#33-プロセスフロー">3.3 プロセスフロー</a></h3>
<pre class="mermaid">flowchart TD
    A[開始] --&gt; B[コンポーネントの作成]
    B --&gt; C[メディエータの作成]
    C --&gt; D[コンポーネントとメディエータの関連付け]
    D --&gt; E[コンポーネントAの操作]
    E --&gt; F[コンポーネントAからメディエータへ通知]
    F --&gt; G[メディエータがイベントを処理]
    G --&gt; H[メディエータが関連コンポーネントを操作]
    H --&gt; I[システム全体の状態が更新される]
    I --&gt; J[終了]
</pre>
<h3 id="34-重要なシナリオ"><a class="header" href="#34-重要なシナリオ">3.4 重要なシナリオ</a></h3>
<h4 id="シナリオ1-チャットアプリケーション"><a class="header" href="#シナリオ1-チャットアプリケーション">シナリオ1: チャットアプリケーション</a></h4>
<ol>
<li>ユーザーがメッセージを作成</li>
<li>ユーザーがメッセージを送信</li>
<li>チャットルーム（メディエータ）がメッセージを受け取る</li>
<li>チャットルームが送信者以外の全ユーザーにメッセージを配信</li>
<li>各ユーザーがメッセージを受信・表示</li>
</ol>
<h4 id="シナリオ2-uiフォーム検証"><a class="header" href="#シナリオ2-uiフォーム検証">シナリオ2: UIフォーム検証</a></h4>
<ol>
<li>ユーザーがフォームフィールドに入力</li>
<li>フォームフィールドが値の変更をメディエータに通知</li>
<li>メディエータが全フィールドの値を収集・検証</li>
<li>バリデーション結果に基づいて送信ボタンの有効/無効を切り替え</li>
<li>ユーザーが送信ボタンをクリック</li>
<li>メディエータがフォーム送信処理を実行</li>
</ol>
<h2 id="4-実装詳細"><a class="header" href="#4-実装詳細">4. 実装詳細</a></h2>
<h3 id="41-主要インターフェースクラス"><a class="header" href="#41-主要インターフェースクラス">4.1 主要インターフェース・クラス</a></h3>
<pre><code class="language-typescript">/**
 * メディエータインターフェース
 * コンポーネント間の通信を仲介する
 */
interface ChatMediator {
    /**
     * メッセージを送信する
     * @param message 送信するメッセージ
     * @param sender 送信者
     */
    sendMessage(message: string, sender: ChatUser): void;
    
    /**
     * ユーザーを追加する
     * @param user 追加するユーザー
     */
    addUser(user: ChatUser): void;
}

/**
 * チャットユーザークラス
 * メッセージの送受信を行う
 */
class ChatUser {
    /**
     * コンストラクタ
     * @param name ユーザー名
     * @param mediator メディエータ
     */
    constructor(
        private name: string,
        private mediator: ChatMediator
    ) {}
    
    /**
     * メッセージを送信する
     * @param message 送信するメッセージ
     */
    send(message: string): void {
        console.log(`${this.name} sends: ${message}`);
        this.mediator.sendMessage(message, this);
    }
    
    /**
     * メッセージを受信する
     * @param message 受信したメッセージ
     */
    receive(message: string): void {
        console.log(`${this.name} receives: ${message}`);
    }
    
    /**
     * ユーザー名を取得する
     * @returns ユーザー名
     */
    getName(): string {
        return this.name;
    }
}

/**
 * チャットルームクラス（コンクリートメディエータ）
 * ユーザー間のメッセージ交換を管理する
 */
class ChatRoom implements ChatMediator {
    /**
     * チャットルームに参加しているユーザーのリスト
     */
    private users: ChatUser[] = [];
    
    /**
     * ユーザーをチャットルームに追加する
     * @param user 追加するユーザー
     */
    addUser(user: ChatUser): void {
        this.users.push(user);
        console.log(`${user.getName()} has joined the chat room`);
    }
    
    /**
     * メッセージを送信する（送信者以外の全ユーザーに配信）
     * @param message 送信するメッセージ
     * @param sender 送信者
     */
    sendMessage(message: string, sender: ChatUser): void {
        // 送信者以外の全ユーザーにメッセージを配信
        this.users.forEach(user =&gt; {
            if (user !== sender) {
                user.receive(message);
            }
        });
    }
}
</code></pre>
<h3 id="42-uiメディエータの実装"><a class="header" href="#42-uiメディエータの実装">4.2 UIメディエータの実装</a></h3>
<pre><code class="language-typescript">/**
 * UIメディエータインターフェース
 * UI要素間の通信を仲介する
 */
interface UIMediator {
    /**
     * コンポーネントからの通知を処理する
     * @param sender 通知の送信元コンポーネント
     * @param event イベント名
     */
    notify(sender: UIComponent, event: string): void;
    
    /**
     * コンポーネントを登録する
     * @param component 登録するコンポーネント
     */
    registerComponent(component: UIComponent): void;
}

/**
 * UI コンポーネント抽象クラス
 * すべてのUI要素の基底クラス
 */
abstract class UIComponent {
    /**
     * このコンポーネントが関連付けられているメディエータ
     */
    protected mediator: UIMediator;
    
    /**
     * メディエータを設定する
     * @param mediator 設定するメディエータ
     */
    setMediator(mediator: UIMediator): void {
        this.mediator = mediator;
        mediator.registerComponent(this);
    }
    
    /**
     * コンポーネント名を取得する
     * @returns コンポーネント名
     */
    abstract getName(): string;
}

/**
 * ボタンコンポーネント
 */
class Button extends UIComponent {
    /**
     * コンストラクタ
     * @param name ボタン名
     */
    constructor(private name: string) {
        super();
    }
    
    /**
     * ボタンクリックイベントをシミュレート
     */
    click(): void {
        console.log(`Button ${this.name} clicked`);
        this.mediator.notify(this, 'click');
    }
    
    /**
     * ボタン名を取得する
     * @returns ボタン名
     */
    getName(): string {
        return this.name;
    }
}

/**
 * テキストボックスコンポーネント
 */
class TextBox extends UIComponent {
    /**
     * テキストボックスの内容
     */
    private text: string = '';
    
    /**
     * コンストラクタ
     * @param name テキストボックス名
     */
    constructor(private name: string) {
        super();
    }
    
    /**
     * テキストを設定する
     * @param text 設定するテキスト
     */
    setText(text: string): void {
        this.text = text;
        console.log(`TextBox ${this.name} text changed to: ${text}`);
        this.mediator.notify(this, 'textChanged');
    }
    
    /**
     * テキストを取得する
     * @returns 現在のテキスト
     */
    getText(): string {
        return this.text;
    }
    
    /**
     * テキストボックス名を取得する
     * @returns テキストボックス名
     */
    getName(): string {
        return this.name;
    }
}

/**
 * ログインフォームメディエータ
 * ログインフォームのUI要素間の連携を管理する
 */
class LoginFormMediator implements UIMediator {
    /**
     * 登録されたコンポーネントのマップ
     */
    private components: Map&lt;string, UIComponent&gt; = new Map();
    
    /**
     * コンポーネントを登録する
     * @param component 登録するコンポーネント
     */
    registerComponent(component: UIComponent): void {
        this.components.set(component.getName(), component);
    }
    
    /**
     * コンポーネントからの通知を処理する
     * @param sender 通知の送信元コンポーネント
     * @param event イベント名
     */
    notify(sender: UIComponent, event: string): void {
        // ボタンクリックイベントの処理
        if (sender instanceof Button &amp;&amp; event === 'click') {
            this.handleLogin();
        }
        
        // テキスト変更イベントの処理
        if (sender instanceof TextBox &amp;&amp; event === 'textChanged') {
            this.validateForm();
        }
    }
    
    /**
     * ログイン処理を実行する
     */
    private handleLogin(): void {
        const username = (this.components.get('username') as TextBox).getText();
        const password = (this.components.get('password') as TextBox).getText();
        
        if (username &amp;&amp; password) {
            console.log('Logging in...');
        } else {
            console.log('Please fill in all fields');
        }
    }
    
    /**
     * フォームのバリデーションを実行する
     */
    private validateForm(): void {
        const username = (this.components.get('username') as TextBox).getText();
        const password = (this.components.get('password') as TextBox).getText();
        
        // ボタンの有効/無効を切り替え
        if (username &amp;&amp; password) {
            console.log('Form is valid');
        } else {
            console.log('Form is invalid');
        }
    }
}
</code></pre>
<h3 id="43-実装のバリエーション"><a class="header" href="#43-実装のバリエーション">4.3 実装のバリエーション</a></h3>
<ol>
<li>
<p><strong>イベント駆動型メディエータ</strong></p>
<ul>
<li>イベントリスナー/エミッターパターンを利用</li>
<li>コンポーネントはイベントを発行し、メディエータがサブスクライブする</li>
</ul>
</li>
<li>
<p><strong>コマンドベースメディエータ</strong></p>
<ul>
<li>コマンドオブジェクトを通じてコンポーネント間の通信を行う</li>
<li>メディエータがコマンドの仲介役となる</li>
</ul>
</li>
<li>
<p><strong>オブザーバーと組み合わせ</strong></p>
<ul>
<li>メディエータがオブザーバーパターンと連携</li>
<li>コンポーネントはObservableとして振舞い、メディエータがObserverとなる</li>
</ul>
</li>
<li>
<p><strong>状態管理メディエータ</strong></p>
<ul>
<li>システム全体の状態を管理し、状態変更に基づいてコンポーネントを更新</li>
<li>Reduxのようなグローバルストアとアクション処理の実装</li>
</ul>
</li>
</ol>
<h3 id="44-注意すべき実装ポイント"><a class="header" href="#44-注意すべき実装ポイント">4.4 注意すべき実装ポイント</a></h3>
<ul>
<li>メディエータが肥大化しすぎないよう、責務を明確に定義する</li>
<li>メディエータのテスト容易性を確保するため、適切な粒度で分割する</li>
<li>コンポーネントはメディエータの実装詳細に依存しないよう設計する</li>
<li>メディエータのコンポーネント参照方法を統一する（名前、ID、直接参照など）</li>
<li>複数のメディエータが存在する場合は責務の境界を明確にする</li>
<li>パフォーマンスを考慮し、不要な通知を最小限に抑える</li>
<li>循環参照や無限ループに注意する</li>
</ul>
<h2 id="5-使用例"><a class="header" href="#5-使用例">5. 使用例</a></h2>
<h3 id="51-基本的な使用例"><a class="header" href="#51-基本的な使用例">5.1 基本的な使用例</a></h3>
<pre><code class="language-typescript">// チャットアプリケーションの基本的な使用例

// チャットルーム（メディエータ）の作成
const chatRoom = new ChatRoom();

// ユーザー（コンポーネント）の作成と登録
const john = new ChatUser('John', chatRoom);
const alice = new ChatUser('Alice', chatRoom);
const bob = new ChatUser('Bob', chatRoom);

chatRoom.addUser(john);
chatRoom.addUser(alice);
chatRoom.addUser(bob);

// メッセージの送信
john.send('Hello everyone!');
alice.send('Hi John!');
bob.send('Hey there!');

// 出力例:
// John has joined the chat room
// Alice has joined the chat room
// Bob has joined the chat room
// John sends: Hello everyone!
// Alice receives: Hello everyone!
// Bob receives: Hello everyone!
// Alice sends: Hi John!
// John receives: Hi John!
// Bob receives: Hi John!
// Bob sends: Hey there!
// John receives: Hey there!
// Alice receives: Hey there!
</code></pre>
<h3 id="52-高度な使用例"><a class="header" href="#52-高度な使用例">5.2 高度な使用例</a></h3>
<pre><code class="language-typescript">// UIコンポーネント連携の高度な使用例

// メディエータの作成
const loginFormMediator = new LoginFormMediator();

// UIコンポーネントの作成
const usernameInput = new TextBox('username');
const passwordInput = new TextBox('password');
const loginButton = new Button('loginButton');
const rememberMeCheckbox = new Checkbox('rememberMe');
const errorLabel = new Label('errorLabel');

// すべてのコンポーネントとメディエータを関連付け
usernameInput.setMediator(loginFormMediator);
passwordInput.setMediator(loginFormMediator);
loginButton.setMediator(loginFormMediator);
rememberMeCheckbox.setMediator(loginFormMediator);
errorLabel.setMediator(loginFormMediator);

// フォームの操作シミュレーション
console.log('--- フォーム入力シミュレーション ---');
usernameInput.setText('user@example.com');
// バリデーションが実行され、エラーラベルが更新される

passwordInput.setText('weak');
// パスワード強度チェックが実行され、エラーラベルが更新される

passwordInput.setText('StrongP@ssw0rd');
// バリデーションが成功し、ログインボタンが有効になる

rememberMeCheckbox.setChecked(true);
// 設定が更新される

loginButton.click();
// ログイン処理が実行される

// 出力例:
// --- フォーム入力シミュレーション ---
// TextBox username text changed to: user@example.com
// Validating form...
// Form is incomplete. Login button disabled.
// Error label updated: Please enter your password
// TextBox password text changed to: weak
// Validating form...
// Form has errors. Login button disabled.
// Error label updated: Password is too weak
// TextBox password text changed to: StrongP@ssw0rd
// Validating form...
// Form is valid. Login button enabled.
// Error label cleared
// Checkbox rememberMe checked: true
// Remember me preference updated
// Button loginButton clicked
// Logging in with credentials:
// Username: user@example.com
// Password: StrongP@ssw0rd
// Remember Me: true
</code></pre>
<h2 id="6-テスト戦略"><a class="header" href="#6-テスト戦略">6. テスト戦略</a></h2>
<h3 id="61-ユニットテスト要件"><a class="header" href="#61-ユニットテスト要件">6.1 ユニットテスト要件</a></h3>
<ul>
<li>各コンポーネントが適切にメディエータに通知することを確認</li>
<li>メディエータが適切なコンポーネントに処理を委譲することを確認</li>
<li>メディエータのイベント処理ロジックが期待通りに動作することを確認</li>
<li>コンポーネントとメディエータの連携が正しいことを検証</li>
<li>エラー処理や境界条件の検証</li>
</ul>
<h3 id="62-テスト実装例"><a class="header" href="#62-テスト実装例">6.2 テスト実装例</a></h3>
<pre><code class="language-typescript">describe('Mediator Pattern Tests', () =&gt; {
    describe('ChatRoom Mediator', () =&gt; {
        let chatRoom: ChatRoom;
        let user1: ChatUser;
        let user2: ChatUser;
        let user3: ChatUser;
        
        beforeEach(() =&gt; {
            // テスト前の初期化
            chatRoom = new ChatRoom();
            user1 = new ChatUser('User1', chatRoom);
            user2 = new ChatUser('User2', chatRoom);
            user3 = new ChatUser('User3', chatRoom);
            
            chatRoom.addUser(user1);
            chatRoom.addUser(user2);
            chatRoom.addUser(user3);
        });
        
        test('should deliver messages to all users except sender', () =&gt; {
            // メッセージ受信のモック
            const spy1 = jest.spyOn(user1, 'receive');
            const spy2 = jest.spyOn(user2, 'receive');
            const spy3 = jest.spyOn(user3, 'receive');
            
            // user1 がメッセージを送信
            user1.send('Hello');
            
            // 検証: 送信者以外がメッセージを受信
            expect(spy1).not.toHaveBeenCalled();
            expect(spy2).toHaveBeenCalledWith('Hello');
            expect(spy3).toHaveBeenCalledWith('Hello');
            
            // スパイをリセット
            jest.clearAllMocks();
            
            // user2 がメッセージを送信
            user2.send('Hi there');
            
            // 検証: 送信者以外がメッセージを受信
            expect(spy1).toHaveBeenCalledWith('Hi there');
            expect(spy2).not.toHaveBeenCalled();
            expect(spy3).toHaveBeenCalledWith('Hi there');
        });
        
        test('should handle empty message', () =&gt; {
            const spy = jest.spyOn(user2, 'receive');
            
            user1.send('');
            
            expect(spy).toHaveBeenCalledWith('');
        });
        
        test('should handle user removal', () =&gt; {
            // ユーザー削除のメソッドを追加
            chatRoom['removeUser'] = function(user: ChatUser): void {
                this.users = this.users.filter(u =&gt; u !== user);
            };
            
            // メッセージ受信のモック
            const spy2 = jest.spyOn(user2, 'receive');
            const spy3 = jest.spyOn(user3, 'receive');
            
            // user2 を削除
            chatRoom['removeUser'](user2);
            
            // user1 がメッセージを送信
            user1.send('After removal');
            
            // 検証: 削除されたユーザーはメッセージを受信しない
            expect(spy2).not.toHaveBeenCalled();
            expect(spy3).toHaveBeenCalledWith('After removal');
        });
    });
    
    describe('LoginForm Mediator', () =&gt; {
        let mediator: LoginFormMediator;
        let usernameInput: TextBox;
        let passwordInput: TextBox;
        let loginButton: Button;
        
        beforeEach(() =&gt; {
            // テスト前の初期化
            mediator = new LoginFormMediator();
            usernameInput = new TextBox('username');
            passwordInput = new TextBox('password');
            loginButton = new Button('loginButton');
            
            usernameInput.setMediator(mediator);
            passwordInput.setMediator(mediator);
            loginButton.setMediator(mediator);
        });
        
        test('should validate form when text changes', () =&gt; {
            // validateForm メソッドのスパイ
            const validateSpy = jest.spyOn(mediator as any, 'validateForm');
            
            // テキスト変更
            usernameInput.setText('test@example.com');
            
            // 検証: validateForm が呼ばれた
            expect(validateSpy).toHaveBeenCalled();
        });
        
        test('should handle login when button clicked', () =&gt; {
            // handleLogin メソッドのスパイ
            const loginSpy = jest.spyOn(mediator as any, 'handleLogin');
            
            // ボタンクリック
            loginButton.click();
            
            // 検証: handleLogin が呼ばれた
            expect(loginSpy).toHaveBeenCalled();
        });
        
        test('should show error when form is incomplete', () =&gt; {
            // コンソール出力のスパイ
            const consoleSpy = jest.spyOn(console, 'log');
            
            // ユーザー名のみ設定
            usernameInput.setText('test@example.com');
            loginButton.click();
            
            // 検証: エラーメッセージが出力された
            expect(consoleSpy).toHaveBeenCalledWith('Please fill in all fields');
        });
        
        test('should proceed with login when form is complete', () =&gt; {
            // コンソール出力のスパイ
            const consoleSpy = jest.spyOn(console, 'log');
            
            // 両方のフィールドを設定
            usernameInput.setText('test@example.com');
            passwordInput.setText('password123');
            loginButton.click();
            
            // 検証: ログイン処理が実行された
            expect(consoleSpy).toHaveBeenCalledWith('Logging in...');
        });
    });
});
</code></pre>
<h2 id="7-評価"><a class="header" href="#7-評価">7. 評価</a></h2>
<h3 id="71-メリット"><a class="header" href="#71-メリット">7.1 メリット</a></h3>
<ul>
<li>オブジェクト間の疎結合が実現され、各コンポーネントの独立性が高まる</li>
<li>オブジェクト間の相互作用が中央で管理され、複雑な通信ロジックが整理される</li>
<li>コンポーネントの再利用性が向上し、別のシステムでも使いやすくなる</li>
<li>コンポーネントの修正・追加が容易になり、システムの拡張性が向上する</li>
<li>コンポーネント間の依存関係がシンプルになり、保守性が向上する</li>
<li>各コンポーネントのテストが容易になる（メディエータをモック化可能）</li>
</ul>
<h3 id="72-デメリット制約"><a class="header" href="#72-デメリット制約">7.2 デメリット・制約</a></h3>
<ul>
<li>メディエータが複雑化しやすく、「神オブジェクト」になるリスクがある</li>
<li>システムの単一障害点になる可能性がある</li>
<li>メディエータの設計・実装が難しく、設計ミスが全体に影響する</li>
<li>コンポーネント数が少ない場合、オーバーエンジニアリングになる可能性がある</li>
<li>パフォーマンスに影響を与える可能性がある（すべての通信がメディエータを経由）</li>
<li>メディエータのテストが複雑になりやすい</li>
</ul>
<h3 id="73-代替パターン関連パターン"><a class="header" href="#73-代替パターン関連パターン">7.3 代替パターン・関連パターン</a></h3>
<ul>
<li><strong>Observer（オブザーバー）パターン</strong>: メディエータと組み合わせて使用することが多い</li>
<li><strong>Façade（ファサード）パターン</strong>: サブシステムを簡素化する点では似ているが、通信の制御は行わない</li>
<li><strong>Command（コマンド）パターン</strong>: メディエータ内でコマンドパターンを使用することが多い</li>
<li><strong>Publish-Subscribe（発行-購読）パターン</strong>: イベント駆動型のメディエータ実装に似ている</li>
<li><strong>MVC/MVVM アーキテクチャ</strong>: コントローラー/ビューモデルはメディエータの一種と考えられる</li>
</ul>
<h2 id="8-参考資料"><a class="header" href="#8-参考資料">8. 参考資料</a></h2>
<h3 id="81-内部リンク"><a class="header" href="#81-内部リンク">8.1 内部リンク</a></h3>
<ul>
<li><a href="../../src/behavioral/mediator">ソースコード</a></li>
<li><a href="../../tests/behavioral/mediator">テストコード</a></li>
</ul>
<h3 id="82-外部リンク"><a class="header" href="#82-外部リンク">8.2 外部リンク</a></h3>
<ul>
<li><a href="https://refactoring.guru/ja/design-patterns/mediator">リファクタリング・グル - Mediator パターン</a></li>
<li><a href="https://www.amazon.co.jp/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">Design Patterns: Elements of Reusable Object-Oriented Software</a></li>
<li><a href="https://www.patterns.dev/posts/mediator-pattern">メディエータパターンの実践的ガイド</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../System-design/patterns/behavioral/iterator.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../System-design/patterns/behavioral/memento.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../System-design/patterns/behavioral/iterator.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../System-design/patterns/behavioral/memento.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../../mermaid.min.js"></script>
        <script src="../../../mermaid-init.js"></script>


    </div>
    </body>
</html>
