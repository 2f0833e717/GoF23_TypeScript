<!DOCTYPE HTML>
<html lang="ja" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>composite - TypeScriptによるデザインパターン実装ガイド</title>


        <!-- Custom HTML head -->

        <meta name="description" content="TypeScriptで実装するGoF23デザインパターン解説ドキュメント">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../../custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../../";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">TypeScriptによるデザインパターン実装ガイド</h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/2f0833e717/gof23-typescript" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/2f0833e717/gof23-typescript/edit/main/./System-design/patterns/structural/composite.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="compositeパターン---木構造の統一的操作"><a class="header" href="#compositeパターン---木構造の統一的操作">Compositeパターン - 木構造の統一的操作</a></h1>
<h2 id="1-概要"><a class="header" href="#1-概要">1. 概要</a></h2>
<h3 id="11-パターンの定義"><a class="header" href="#11-パターンの定義">1.1 パターンの定義</a></h3>
<p>Compositeパターン（コンポジット・パターン）は、個々のオブジェクトと複合オブジェクトを同じインターフェースで扱えるようにするデザインパターンです。このパターンを用いると、クライアントは個別オブジェクトとオブジェクトのコレクションを同じ方法で扱うことができます。</p>
<h3 id="12-目的解決する問題"><a class="header" href="#12-目的解決する問題">1.2 目的・解決する問題</a></h3>
<ul>
<li>部分-全体の階層構造（木構造）を表現する</li>
<li>クライアントが単一オブジェクトと複合オブジェクトを区別せずに扱えるようにする</li>
<li>再帰的な構造を簡潔かつ直感的に表現する</li>
<li>階層構造全体に対して処理を適用できるようにする</li>
<li>操作の一貫性を保ちつつ、複雑な構造を表現する</li>
</ul>
<h3 id="13-コンテキスト適用場面"><a class="header" href="#13-コンテキスト適用場面">1.3 コンテキスト・適用場面</a></h3>
<ul>
<li>ファイルシステム（ファイルとディレクトリ）の表現</li>
<li>グラフィカルユーザーインターフェース（コンポーネントとコンテナ）</li>
<li>組織構造（従業員と部門）の表現</li>
<li>メニュー構造（メニューとサブメニュー）</li>
<li>複合図形の描画（線、円、グループ）</li>
<li>複雑な数式や構文木の表現</li>
</ul>
<h2 id="2-クラス構造"><a class="header" href="#2-クラス構造">2. クラス構造</a></h2>
<h3 id="21-クラス図"><a class="header" href="#21-クラス図">2.1 クラス図</a></h3>
<pre class="mermaid">classDiagram
    class Component {
        &lt;&lt;interface&gt;&gt;
        +operation()
        +add(component)
        +remove(component)
        +getChild(index)
    }
    
    class Leaf {
        +operation()
    }
    
    class Composite {
        -children: Component[]
        +operation()
        +add(component)
        +remove(component)
        +getChild(index)
    }
    
    class Client {
        +executeOperation()
    }
    
    Component &lt;|-- Leaf
    Component &lt;|-- Composite
    Composite o-- Component : contains
    Client --&gt; Component
    
    note for Component &quot;共通のインターフェース\n単一オブジェクトと複合オブジェクト\n両方に適用&quot;
    note for Leaf &quot;末端オブジェクト\n子を持たない&quot;
    note for Composite &quot;複合オブジェクト\n子コンポーネントを\n保持・管理する&quot;
    note for Client &quot;コンポーネントを\n操作するクラス&quot;
</pre>
<h3 id="22-主要コンポーネント"><a class="header" href="#22-主要コンポーネント">2.2 主要コンポーネント</a></h3>
<div class="table-wrapper"><table><thead><tr><th>コンポーネント</th><th>種類</th><th>責務</th><th>関連</th></tr></thead><tbody>
<tr><td>Component</td><td>インターフェース/抽象クラス</td><td>共通操作のインターフェースを定義し、子オブジェクト管理のためのメソッドを提供</td><td>Leaf、Compositeの親クラス</td></tr>
<tr><td>Leaf</td><td>クラス</td><td>単一オブジェクトを表し、子オブジェクトを持たない</td><td>Componentを実装/継承</td></tr>
<tr><td>Composite</td><td>クラス</td><td>子コンポーネントを保持・管理し、操作を子に委譲する</td><td>Componentを実装/継承、複数のComponentを含む</td></tr>
<tr><td>Client</td><td>クラス</td><td>Componentインターフェースを使用して構造を操作</td><td>Componentを使用</td></tr>
</tbody></table>
</div>
<h3 id="23-相互作用"><a class="header" href="#23-相互作用">2.3 相互作用</a></h3>
<ul>
<li>Component: 全てのオブジェクトに共通の操作と子オブジェクト管理のためのインターフェースを定義</li>
<li>Leaf: 単一オブジェクトで、Componentの操作メソッドを実装し、子の管理メソッドはデフォルト実装または例外を投げる</li>
<li>Composite: 子コンポーネントを保持し、Componentの操作メソッドを子コンポーネントに委譲し、子の管理メソッドを実装</li>
<li>Client: Componentインターフェースを通じて操作を行い、LeafとCompositeを区別せずに扱う</li>
</ul>
<h2 id="3-振る舞い"><a class="header" href="#3-振る舞い">3. 振る舞い</a></h2>
<h3 id="31-シーケンス図"><a class="header" href="#31-シーケンス図">3.1 シーケンス図</a></h3>
<pre class="mermaid">sequenceDiagram
    participant Client
    participant Root as Composite (Root)
    participant Branch as Composite (Branch)
    participant Leaf1
    participant Leaf2
    
    Client-&gt;&gt;Root: operation()
    activate Root
    
    Root-&gt;&gt;Branch: operation()
    activate Branch
    
    Branch-&gt;&gt;Leaf1: operation()
    activate Leaf1
    Leaf1--&gt;&gt;Branch: result
    deactivate Leaf1
    
    Branch-&gt;&gt;Leaf2: operation()
    activate Leaf2
    Leaf2--&gt;&gt;Branch: result
    deactivate Leaf2
    
    Branch--&gt;&gt;Root: combined result
    deactivate Branch
    
    Root--&gt;&gt;Client: final result
    deactivate Root
</pre>
<h3 id="32-プロセスフロー"><a class="header" href="#32-プロセスフロー">3.2 プロセスフロー</a></h3>
<pre class="mermaid">flowchart TD
    A[開始] --&gt; B[Clientが根Compositeを生成]
    B --&gt; C[Clientが複数のLeafとCompositeを生成]
    C --&gt; D[Clientが根Compositeに子要素を追加]
    D --&gt; E[Clientが子Compositeに子要素を追加]
    E --&gt; F[Clientが根Compositeのoperationを呼び出す]
    F --&gt; G[根Compositeが自身の各子のoperationを呼び出す]
    G --&gt; H[子Compositeが自身の各子のoperationを呼び出す]
    H --&gt; I[各Leafが自身のoperationを実行]
    I --&gt; J[結果が階層を上って集約される]
    J --&gt; K[Clientが最終結果を受け取る]
    K --&gt; L[終了]
</pre>
<h3 id="33-重要なシナリオ"><a class="header" href="#33-重要なシナリオ">3.3 重要なシナリオ</a></h3>
<h4 id="シナリオ1-ファイルシステムのサイズ計算"><a class="header" href="#シナリオ1-ファイルシステムのサイズ計算">シナリオ1: ファイルシステムのサイズ計算</a></h4>
<ol>
<li>クライアントがルートディレクトリオブジェクト（Composite）を作成</li>
<li>クライアントがファイル（Leaf）とサブディレクトリ（Composite）を追加</li>
<li>クライアントがルートディレクトリの合計サイズを計算するoperationを呼び出す</li>
<li>ルートディレクトリが子である各ファイルとサブディレクトリのoperationを呼び出す</li>
<li>サブディレクトリが自身の子のoperationを呼び出す</li>
<li>各ファイルがサイズを返す</li>
<li>各ディレクトリが子のサイズを合計して返す</li>
<li>クライアントが最終的な合計サイズを受け取る</li>
</ol>
<h4 id="シナリオ2-guiコンポーネントの描画"><a class="header" href="#シナリオ2-guiコンポーネントの描画">シナリオ2: GUIコンポーネントの描画</a></h4>
<ol>
<li>クライアントがフォーム（Composite）を作成</li>
<li>クライアントがパネル（Composite）とボタン（Leaf）を追加</li>
<li>クライアントがパネルにラベルとテキストフィールド（Leaf）を追加</li>
<li>クライアントがフォームの描画（operation）を呼び出す</li>
<li>フォームが子である各パネルとボタンの描画（operation）を呼び出す</li>
<li>パネルが自身の子であるラベルとテキストフィールドの描画を呼び出す</li>
<li>各コンポーネントが描画される</li>
<li>描画が階層的に完了する</li>
</ol>
<h2 id="4-実装詳細"><a class="header" href="#4-実装詳細">4. 実装詳細</a></h2>
<h3 id="41-主要インターフェースクラス"><a class="header" href="#41-主要インターフェースクラス">4.1 主要インターフェース・クラス</a></h3>
<pre><code class="language-typescript">/**
 * Component - ファイルシステム要素の共通インターフェース
 */
interface FileSystemComponent {
  /**
   * ファイル名を取得する
   * @returns ファイル名
   */
  getName(): string;
  
  /**
   * ファイルシステム要素のサイズを計算する
   * @returns サイズ（バイト）
   */
  getSize(): number;
  
  /**
   * ファイルシステム要素の情報を表示する
   * @param indent インデントレベル
   */
  print(indent: string): void;
  
  /**
   * 子要素を追加する（ディレクトリの場合）
   * @param component 追加する要素
   */
  add(component: FileSystemComponent): void;
  
  /**
   * 子要素を削除する（ディレクトリの場合）
   * @param component 削除する要素
   */
  remove(component: FileSystemComponent): void;
  
  /**
   * 指定したインデックスの子要素を取得する（ディレクトリの場合）
   * @param index 取得する子要素のインデックス
   * @returns 子要素
   */
  getChild(index: number): FileSystemComponent;
}

/**
 * Leaf - ファイルを表現するクラス
 */
class File implements FileSystemComponent {
  private name: string;
  private size: number;
  
  /**
   * コンストラクタ
   * @param name ファイル名
   * @param size ファイルサイズ（バイト）
   */
  constructor(name: string, size: number) {
    this.name = name;
    this.size = size;
  }
  
  /**
   * ファイル名を取得する
   * @returns ファイル名
   */
  getName(): string {
    return this.name;
  }
  
  /**
   * ファイルサイズを取得する
   * @returns ファイルサイズ（バイト）
   */
  getSize(): number {
    return this.size;
  }
  
  /**
   * ファイル情報を表示する
   * @param indent インデントレベル
   */
  print(indent: string): void {
    console.log(`${indent}File: ${this.name} (${this.size} bytes)`);
  }
  
  /**
   * ファイルは子要素を持てないため、例外をスローする
   * @param component 追加しようとする要素
   */
  add(component: FileSystemComponent): void {
    throw new Error("Cannot add to a file");
  }
  
  /**
   * ファイルは子要素を持てないため、例外をスローする
   * @param component 削除しようとする要素
   */
  remove(component: FileSystemComponent): void {
    throw new Error("Cannot remove from a file");
  }
  
  /**
   * ファイルは子要素を持てないため、例外をスローする
   * @param index 取得しようとする子要素のインデックス
   */
  getChild(index: number): FileSystemComponent {
    throw new Error("Cannot get child from a file");
  }
}

/**
 * Composite - ディレクトリを表現するクラス
 */
class Directory implements FileSystemComponent {
  private name: string;
  private children: FileSystemComponent[] = [];
  
  /**
   * コンストラクタ
   * @param name ディレクトリ名
   */
  constructor(name: string) {
    this.name = name;
  }
  
  /**
   * ディレクトリ名を取得する
   * @returns ディレクトリ名
   */
  getName(): string {
    return this.name;
  }
  
  /**
   * ディレクトリの合計サイズを計算する（再帰的に子要素のサイズを合計）
   * @returns 合計サイズ（バイト）
   */
  getSize(): number {
    let totalSize = 0;
    for (const child of this.children) {
      totalSize += child.getSize();
    }
    return totalSize;
  }
  
  /**
   * ディレクトリ情報を表示する（再帰的に子要素の情報も表示）
   * @param indent インデントレベル
   */
  print(indent: string): void {
    console.log(`${indent}Directory: ${this.name} (${this.getSize()} bytes)`);
    for (const child of this.children) {
      child.print(indent + "  ");
    }
  }
  
  /**
   * 子要素を追加する
   * @param component 追加する要素
   */
  add(component: FileSystemComponent): void {
    this.children.push(component);
  }
  
  /**
   * 子要素を削除する
   * @param component 削除する要素
   */
  remove(component: FileSystemComponent): void {
    const index = this.children.indexOf(component);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
  }
  
  /**
   * 指定したインデックスの子要素を取得する
   * @param index 取得する子要素のインデックス
   * @returns 子要素
   */
  getChild(index: number): FileSystemComponent {
    return this.children[index];
  }
}
</code></pre>
<h3 id="42-使用例"><a class="header" href="#42-使用例">4.2 使用例</a></h3>
<pre><code class="language-typescript">/**
 * クライアントコード
 */
function clientCode() {
  // ルートディレクトリを作成
  const root = new Directory("root");
  
  // ファイルをルートに追加
  const readmeFile = new File("README.md", 2048);
  root.add(readmeFile);
  
  // サブディレクトリを作成
  const srcDir = new Directory("src");
  root.add(srcDir);
  
  // サブディレクトリにファイルを追加
  const indexFile = new File("index.ts", 1024);
  const appFile = new File("app.ts", 4096);
  srcDir.add(indexFile);
  srcDir.add(appFile);
  
  // もう一つのサブディレクトリを作成
  const testDir = new Directory("test");
  root.add(testDir);
  
  // テストディレクトリにファイルを追加
  const testFile = new File("app.test.ts", 3072);
  testDir.add(testFile);
  
  // 階層構造を表示
  console.log("ファイルシステム構造:");
  root.print("");
  
  // 合計サイズを計算
  console.log(`\n合計サイズ: ${root.getSize()} bytes`);
  
  // サブディレクトリのサイズも個別に取得可能
  console.log(`srcディレクトリのサイズ: ${srcDir.getSize()} bytes`);
  console.log(`testディレクトリのサイズ: ${testDir.getSize()} bytes`);
  
  // 子要素を削除
  console.log("\nindexファイルを削除した後:");
  srcDir.remove(indexFile);
  root.print("");
}

// クライアントコードを実行
clientCode();

// 出力例:
// ファイルシステム構造:
// Directory: root (10240 bytes)
//   File: README.md (2048 bytes)
//   Directory: src (5120 bytes)
//     File: index.ts (1024 bytes)
//     File: app.ts (4096 bytes)
//   Directory: test (3072 bytes)
//     File: app.test.ts (3072 bytes)
//
// 合計サイズ: 10240 bytes
// srcディレクトリのサイズ: 5120 bytes
// testディレクトリのサイズ: 3072 bytes
//
// indexファイルを削除した後:
// Directory: root (9216 bytes)
//   File: README.md (2048 bytes)
//   Directory: src (4096 bytes)
//     File: app.ts (4096 bytes)
//   Directory: test (3072 bytes)
//     File: app.test.ts (3072 bytes)
</code></pre>
<h2 id="5-パターンのバリエーション"><a class="header" href="#5-パターンのバリエーション">5. パターンのバリエーション</a></h2>
<h3 id="51-安全compositesafe-composite"><a class="header" href="#51-安全compositesafe-composite">5.1 安全Composite（Safe Composite）</a></h3>
<p>子コンポーネント管理のメソッド（add, remove, getChild）をCompositeクラスだけに定義し、Componentインターフェースには含めないバージョン。型の安全性は高まるが、クライアントがLeafとCompositeを区別する必要がある。</p>
<pre><code class="language-typescript">// 安全Compositeパターンの例
interface Component {
  // 共通操作のみ定義
  operation(): void;
}

class Leaf implements Component {
  operation(): void {
    console.log("Leaf operation");
  }
}

class Composite implements Component {
  private children: Component[] = [];
  
  operation(): void {
    console.log("Composite operation:");
    for (const child of this.children) {
      child.operation();
    }
  }
  
  // Compositeクラスにのみ子管理メソッドを定義
  add(component: Component): void {
    this.children.push(component);
  }
  
  remove(component: Component): void {
    const index = this.children.indexOf(component);
    if (index !== -1) {
      this.children.splice(index, 1);
    }
  }
  
  getChild(index: number): Component {
    return this.children[index];
  }
}
</code></pre>
<h3 id="52-透過的compositetransparent-composite"><a class="header" href="#52-透過的compositetransparent-composite">5.2 透過的Composite（Transparent Composite）</a></h3>
<p>基本的なCompositeパターンで、Componentインターフェースにすべてのメソッドを含め、クライアントがLeafとCompositeを区別せずに扱えるようにする。柔軟性は高いが、型の安全性は低くなる。</p>
<pre><code class="language-typescript">// 透過的Compositeパターンの例（基本的なCompositeパターン）
interface Component {
  // 共通操作と子管理メソッドを両方定義
  operation(): void;
  add(component: Component): void;
  remove(component: Component): void;
  getChild(index: number): Component;
}

class Leaf implements Component {
  operation(): void {
    console.log("Leaf operation");
  }
  
  // 空実装または例外をスロー
  add(component: Component): void {
    throw new Error("Cannot add to a leaf");
  }
  
  remove(component: Component): void {
    throw new Error("Cannot remove from a leaf");
  }
  
  getChild(index: number): Component {
    throw new Error("Cannot get child from a leaf");
  }
}

// Compositeの実装は変わらない
</code></pre>
<h2 id="6-評価"><a class="header" href="#6-評価">6. 評価</a></h2>
<h3 id="61-メリット"><a class="header" href="#61-メリット">6.1 メリット</a></h3>
<ul>
<li><strong>統一的なインターフェース</strong>: 単一オブジェクトと複合オブジェクトを同じ方法で扱えるため、クライアントコードがシンプルになる</li>
<li><strong>階層構造の表現</strong>: 木構造を自然に表現でき、再帰的な処理が可能</li>
<li><strong>開放/閉鎖原則</strong>: 新たな種類のコンポーネントを追加しても既存のコードを変更する必要がない</li>
<li><strong>コードの再利用</strong>: 同じコンポーネントを異なる階層構造で再利用できる</li>
<li><strong>再帰的処理の簡素化</strong>: 階層構造全体に対する操作を簡潔に実装できる</li>
<li><strong>拡張性</strong>: 構造を動的に構築・変更できる</li>
</ul>
<h3 id="62-デメリット"><a class="header" href="#62-デメリット">6.2 デメリット</a></h3>
<ul>
<li><strong>デザインの制約</strong>: すべてのコンポーネントが共通インターフェースを共有するため、コンポーネント固有の機能を追加しづらい</li>
<li><strong>型の安全性</strong>: 透過的アプローチでは、LeafオブジェクトにCompositeの操作を適用しようとするとランタイムエラーが発生する可能性がある</li>
<li><strong>過剰な一般化</strong>: 単一/複合オブジェクトの区別が必要ない場合、不必要な複雑さを招く可能性がある</li>
<li><strong>パフォーマンス</strong>: 深い階層構造では、再帰的な操作がパフォーマンス問題を引き起こす可能性がある</li>
<li><strong>コンポーネント削除の複雑さ</strong>: 親への参照がない場合、特定のコンポーネントを階層から削除するのが難しい</li>
</ul>
<h3 id="63-適用場面"><a class="header" href="#63-適用場面">6.3 適用場面</a></h3>
<ul>
<li>部分-全体の階層（木構造）を表現する必要がある場合</li>
<li>クライアントが単一オブジェクトと複合オブジェクトを区別せずに扱いたい場合</li>
<li>以下のような具体的なアプリケーション:
<ul>
<li>ファイルシステムの表現</li>
<li>GUIコンポーネントの階層</li>
<li>組織構造の表現</li>
<li>メニュー構造</li>
<li>複合図形の描画</li>
<li>数式や構文木の表現</li>
<li>XMLやHTMLなどの階層的ドキュメント</li>
</ul>
</li>
</ul>
<h2 id="7-関連パターン"><a class="header" href="#7-関連パターン">7. 関連パターン</a></h2>
<ul>
<li><strong>Decorator</strong>: 単一のコンポーネントに責任を追加するが、Compositeは複数のオブジェクトをまとめる</li>
<li><strong>Iterator</strong>: Compositeパターンで構築された複雑な構造を走査するのに役立つ</li>
<li><strong>Visitor</strong>: Compositeパターンで構築された構造に対して、新しい操作を追加するのに役立つ</li>
<li><strong>Chain of Responsibility</strong>: コマンドを階層的に処理する際にCompositeと組み合わせることがある</li>
<li><strong>Flyweight</strong>: Compositeパターンとともに使用して、複合オブジェクトの記憶効率を向上させることがある</li>
</ul>
<h2 id="8-参考資料"><a class="header" href="#8-参考資料">8. 参考資料</a></h2>
<h3 id="81-内部リンク"><a class="header" href="#81-内部リンク">8.1 内部リンク</a></h3>
<ul>
<li><a href="../../src/structural/composite">ソースコードへのリンク</a></li>
<li><a href="../../tests/structural/composite">テストコードへのリンク</a></li>
</ul>
<h3 id="82-外部リンク"><a class="header" href="#82-外部リンク">8.2 外部リンク</a></h3>
<ul>
<li><a href="https://refactoring.guru/ja/design-patterns/composite">リファクタリング・グル - Compositeパターン</a></li>
<li><a href="https://sourcemaking.com/design_patterns/composite">Design Patterns: Composite Pattern</a></li>
<li><a href="https://www.oreilly.co.jp/books/9784873119762/">Head First デザインパターン</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../System-design/patterns/structural/bridge.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../System-design/patterns/structural/decorator.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../System-design/patterns/structural/bridge.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../System-design/patterns/structural/decorator.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js"></script>
        <script src="../../../mark.min.js"></script>
        <script src="../../../searcher.js"></script>

        <script src="../../../clipboard.min.js"></script>
        <script src="../../../highlight.js"></script>
        <script src="../../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../../mermaid.min.js"></script>
        <script src="../../../mermaid-init.js"></script>


    </div>
    </body>
</html>
